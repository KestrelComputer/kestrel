\ Get the version of the STS kernel.
: getver ( -- rev minor major )
	d# 0 >d  d# 5 >d  d# 1 >d  ;

\ Exits the emulator with return code 0.
extern bye

\ Supports vectored execution.
extern call

\ Sends the character to the user's console.
\ : emit ( ch - )
\	0 d@ >d bemit  d> d# $0E00000000000000 c! ;

extern emit

\ Takes the tail of a string.
: nextch ( addr len - addr+1 len-1 )
	d> d> d# 1 + >d d# 1 - >d ;

\ Sends a string of length len to the console.
: type ( addr len - )
	begin 0 d@ while 1 d@ c@ >d emit nextch repeat d> d> drop drop ;

\ Various console control characters.
: cr ( - )	d# 13 >d emit d# 10 >d emit ;
: space ( - )	d# 32 >d emit ;
: backspace	d# 8 >d emit ;

\ For debugging, _64 is used to print a 64-bit value in hex.
: shr4		d> u2/ u2/ u2/ u2/ >d ;
: shr15		shr4 shr4 shr4 d> u2/ u2/ u2/ >d ;
: shr30		shr15 shr15 ;
: shl4		d> 2* 2* 2* 2* >d ;
: _1		d> S" 0123456789ABCDEF" nip + c@ >d emit ;
: _4		0 d@ >d shr30 shr30 _1  shl4 ;
: _16		_4 _4 _4 _4 ;
: _64		_16 _16 _16 _16 d> ;

\ Filesystem error codes.

-1 const ErrNotFound	( resource not found )
-2 const ErrRelative	( path not absolute )
-3 const ErrIsIterable	( resource is not a file, but requires iteration )
-4 const ErrNoMemory	( out of memory )
-5 const ErrTooBig	( request is too big )
-6 const ErrNotExec	( file is not a recognized executable )
-7 const ErrInUse	( resource is still in use )

\ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

\ These routines provide a dynamic memory management facility, allowing
\ applications to request blocks of memory of a given size, and to release it
\ later if required.
\ 
\ Pools are maintained through a singly linked, circular list of nodes with
\ the invariant that a node N can point to node M if and only if M appears at
\ a higher address than N, and which follows N immediately.  So, if looking at
\ a memory dump of three nodes, A, B, and C in that order, A generally cannot
\ point directly to C.  The sole exception is if A and B both represent free
\ chunks of memory, where B's space coalesces with A to reduce fragmentation.
\ An order like A, C, B is simply right out, no matter what.  If this happens,
\ the memory pool is corrupted, and will inevitably lead to a crash.
\ 
\ The structure of a node follows (offsets in cells):
\ 
\ +0	next		Pointer to next node in the list, or back to first
\			node.
\ 
\ +1	--1111....	The size of the allocation, in bytes, excluding the
\			header.  Note that memory may not be requested in
\			units smaller than sixteen bytes.
\ 
\ +1	--....111.	Unused bits.  Must be set to zero on writing, and
\			ignored on read.
\ 
\ +1	--.......1	1=block is allocated; 0=block is free.

dword: mplsta	\ Memory Pool Start
dword: mplsiz	\ Memory Pool Size

\ fmtmem formats a memory pool with the required metadata to support
\ allocation requests.  The mplsta variable must point to the start of the
\ memory pool, while mplsiz must contain its size, in bytes.  fmtmem does not
\ return, and cannot fail.
\
\ Beware: formatting a pool that's been previously used will, in effect,
\ forcefully deallocate everything from that pool.

: fmtmem ( a u -- )
	d> mplsiz ! d> mplsta !
	mplsta @ mplsta @ !	( circular list node points to itself )
	mplsiz @ d# -16 and d# 16 -	( size of first free block )
	mplsta @ d# 8 + ! ;

\ getmem allocates at least u bytes of memory.  If successful it returns the
\ address of the allocated block, and a success flag.  Otherwise, undefined
\ results and a false flag are returned.

: gmsplit ( u a -- u a )
	\ Make sure that it makes sense to split.
	\ The current space must hold at least one header and
	\ one 16 byte block, totalling 32 bytes, after splitting.
	1 d@ d# 32 + 0 d@ d# 8 + @ d# -16 and -
	-if
		0 d@ 1 d@ + d# 16 + >d		( addr of next block )
			1 d@ @ 0 d@ !		( link to next block )
			1 d@ d# 8 + @  2 d@ - d# 16 -
				0 d@ d# 8 + !	( size of next block )
			0 d@  1 d@ !		( this blk -> next )
			2 d@ d# 1 or  1 d@ d# 8 + !
		d>
	else
		( Too small to split; just mark whole thing allocated )
		0 d@ d# 8 + @  d# 1 or  0 d@ d# 8 + !
	then ;

: getmem ( u -- a -1 | ? 0 )
	d> d# 15 + d# -16 and >d	( round to at least 16 bytes )

	mplsta @ >d

	begin ( u a )
		\ Search for a free block.

		begin 0 d@ d# 8 + @ d# 1 and while
			d> @ >d				( next mem block )
			0 d@ mplsta @ xor 0=if		( all blocks alloc'ed )
				d# 0 0 d! exit
			then
		repeat

		\ here, 0 d@ points to a free block.
		\ It still might be too small though.
		\ Let's try to coalesce with an adjacent
		\ free block, if one exists.

		0 d@ @ >d d# 1 >d ( a b continue )
		begin 0 d@ while
			1 d@ mplsta @ xor 0=if
				d> d# 0 >d
			else
			1 d@ d# 8 + @ d# 1 and if
				\ Adjacent block is allocated; stop coalescing
				d> d# 0 >d
			else
				\ Assimilate node b's total size.
				d# 16		( size of b's header )
				1 d@ d# 8 + @ + ( size of b's block )
				2 d@ d# 8 + @ + ( size of a's block )
				2 d@ d# 8 + !

				\ Fix linkage
				1 d@ @ 2 d@ !	( a.next = b.next )
				1 d@ @ 1 d!	( b = b.next )
			then then
		repeat
		d> d>	( Discard continue flag and node b reference )

		\ We have as large a free block as we can get.
		\ Let's hope for the best.

		0 d@ d# 8 + @ d# -16 and  1 d@ -  +if	( block is big enough )
			gmsplit
			0 d@ d# 16 + 1 d!  d# -1 0 d!  exit
		then

		\ Block too small, try the next block.

		d> @ >d
		0 d@ mplsta @ xor 0=if d# 0 0 d! exit then
	again ;

\ fremem releases a block of memory, whose pointer was returned by the
\ getmem procedure.

: fremem ( a -- )
	\ Clear allocated bit.

	d> d# 16 - >d		( recover header address )
	0 d@ d# 8 + @ d# -16 and 0 d@ d# 8 + !

	\ Coalesce free blocks of memory downstream.

	0 d@ @ >d ( a b )
	begin 0 d@ d# 8 + @ d# 1 and d# 1 xor while
		\ Assimilate node b's total size.
		d# 16		( size of b's header )
		0 d@ d# 8 + @ + ( size of b's block )
		1 d@ d# 8 + @ + ( size of a's block )
		1 d@ d# 8 + !

		\ Fix linkage
		0 d@ @ 1 d@ !	( a.next = b.next )
		0 d@ @ 0 d!	( b = b.next )

		\ Early exit if we reach end of memory list
		0 d@ mplsta @ xor 0=if
			d> d> exit
		then
	repeat
	d> d> ;

\ Moves a block of memory from src to dst.  The block moved will consist
\ of len bytes.  NOTE: Currently, it does not handle overlapping blocks
\ of memory.  It implements a simple, slow, byte-granular, ascending
\ memory move.

: movmem ( src dst len -- )
	begin
		0 d@ 0=if d> d> d> exit then
		2 d@ c@ 1 d@ c!
		2 d@ d# 1 + 2 d!
		1 d@ d# 1 + 1 d!
		0 d@ d# 1 - 0 d!
	again ;

\ Sets a block of memory to an arbitrary byte value.

: setmem ( dst len c -- )
	begin
		1 d@ 0=if d> d> d> exit then
		0 d@ 2 d@ c!
		2 d@ d# 1 + 2 d!
		1 d@ d# 1 - 1 d!
	again ;

\ Zeros a block of memory.

: zermem ( dst len -- )
	d# 0 >d setmem ;

\ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\ This code is a test suite for getmem and fremem.

: get0		d# 1024 >d getmem
		d> 0=if S" expected non-null address from getmem" >d >d type cr bye then
		0 d@ h# 2010 xor if S" Expected block at $2010, got:" >d >d type _64 cr bye then ;
: get1		d# 1024 >d getmem
		d> 0=if S" expected non-null addr from getmem 2" >d >d type cr bye then
		0 d@ h# 2420 xor if S" Expected block at $2420, got:" >d >d type _64 cr bye then ;
: get2		d# 1024 >d getmem
		d> 0=if S" expected non-null addr from getmem 3" >d >d type cr bye then
		0 d@ h# 2830 xor if S" Expected block at $2830, got:" >d >d type _64 cr bye then ;
: get3		d# 1024 >d getmem
		d> 0=if S" expected non-null addr from getmem 4" >d >d type cr bye then
		0 d@ h# 2420 xor if S" Expected block at $2420 (get3), got:" >d >d type _64 cr bye then ;

: get4		d# 2048 >d getmem
		d> 0=if S" expected non-null address from getmem 5" >d >d type cr bye then
		0 d@ h# 2010 xor if S" Expected 2K block at $2010 (get4), got:" >d >d type _64 cr bye then ;
: get5		d# 2048 >d getmem
		d> 0=if S" expected non-null address from getmem 6" >d >d type cr bye then
		0 d@ h# 2C40 xor if S" Expected 2K block at $2C40 (get5), got:" >d >d type _64 cr bye then ;
: get6		d# 1048576 >d getmem
		d> 0=if S" expected non-null address from getmem 7" >d >d type cr bye then
		0 d@ h# 2010 xor if S" Expected 1M block at $2010 (get6), got:" >d >d type _64 cr bye then ;


: fre0		h# 2010 >d fremem ;
: fre1		h# 2420 >d fremem ;
: fre2		h# 2830 >d fremem ;
: fre3		h# 2C40 >d fremem ;

: memtest   exit ( need to relocate addresses in test )
	S" memtest:" >d >d type cr
	get0 get1 get2 fre1 get3 fre1 fre0 get4 get5 fre0 fre3 fre2 get6
	S" OK" >d >d type cr ;

\ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\
\ The string library maintains useful string-related procedures.


\ BSPL cannot record an empty string with S" ", so this procedure
\ pushes a zero-length string onto the stack manually.
: _emptystr
	d# 0 >d d# 0 >d ;

\ Duplicate a string in memory.  The only way this can fail is
\ if no memory is available for allocation; in this case, 0
\ is returned.  Otherwise, a suitably sized block of memory
\ is allocated, and the original string copied into it.  The
\ address returned is that of the new string.
\ 
\ Note that the caller is responsible for invoking fremem on
\ the duplicated string.

: strDup ( caddr u -- caddr' -1 | ? 0 )
	0 d@ >d getmem  0 d@ 0=if
		d> d> d# 0 >d exit
	then d>
	1 d@ >d		( caddr u caddr' u )
	3 d@ 2 d!	( caddr caddr caddr' u )
	1 d@ 3 d!	( caddr' caddr caddr' u )
	movmem d# -1 >d ;

\ Return true if and only if the two strings match, including
\ case.

extern asmstrcmp

: strEql ( a1 u1 a2 u2 -- -1 | 0 )
	asmstrcmp d> 0=if d# -1 >d exit then
	d# 0 >d ;

\ Splits a string at the first slash, intended for filesystem
\ navigation purposes.  This procedure always returns two strings.
\ The table below explains the relationship between an input string
\ I, and the resulting prefix string P and suffix string S:
\
\ I		P		S
\ ""		""		""
\ "/"		""		""
\ "foo"		"foo"		""
\ "foo/"	"foo"		""
\ "/foo"	""		"foo"
\ "/foo/"	""		"foo/"
\ "foo/bar"	"foo"		"bar"
\ "foo/bar/"	"foo"		"bar/"
\ "///"		""		"//"

: strSplitSlash ( ia iu -- sa su pa pu )
	1 d@ >d d# 0 >d		( sa su pa pu )
	begin
		2 d@ 0=if exit then
		3 d@ c@ char / lit, xor 0=if
			2 d@ d# 1 - 2 d!
			3 d@ d# 1 + 3 d!
			exit
		then
		0 d@ d# 1 + 0 d!
		2 d@ d# 1 - 2 d!
		3 d@ d# 1 + 3 d!
	again ;
		
: strTSplitEmpty
	_emptystr strSplitSlash
		d> if S"   splitEmpty: prefix length" >d >d type cr bye then d>
		d> if S"   splitEmpty: suffix length" >d >d type cr bye then d>
	S" /" >d >d strSplitSlash
		d> if S"   splitEmpty: / prefix length" >d >d type cr bye then d>
		d> if S"   splitEmpty: / suffix length" >d >d type cr bye then d> ;

: strTSplitSlash
	S" foo" >d >d strSplitSlash
		d> d# 3 xor if S"   splitSlash: prefix length" >d >d type cr bye then
		d# 3 >d S" foo" >d >d strEql d> 0=if S"   splitSlash: prefix" >d >d type cr bye then
		d> if S"   splitSlash: suffix length" >d >d type cr bye then d>
	S" foo/" >d >d strSplitSlash
		d> d# 3 xor if S"   splitSlash: / prefix length" >d >d type cr bye then
		d# 3 >d S" foo" >d >d strEql d> 0=if S"   splitSlash: / prefix" >d >d type cr bye then
		d> if S"   splitSlash: / suffix length" >d >d type cr bye then d>
	S" /foo" >d >d strSplitSlash
		d> if S"   splitSlash: prefix length /foo" >d >d type cr bye then d>
		d> d# 3 xor if S"   splitSlash: suffix length /foo" >d >d type cr bye then
		d# 3 >d S" foo" >d >d strEql d> 0=if S"   splitSlash: suffix /foo" >d >d type cr bye then
	S" /foo/" >d >d strSplitSlash
		d> if S"   splitSlash: prefix length /foo/" >d >d type cr bye then d>
		d> d# 4 xor if S"   splitSlash: suffix length /foo/" >d >d type cr bye then
		d# 4 >d S" foo/" >d >d strEql d> 0=if S"   splitSlash: suffix /foo/" >d >d type cr bye then ;

: strTSplitBlort
	S" foo/blort" >d >d strSplitSlash
		d> d# 3 xor if S"   splitBlort: prefix length" >d >d type cr bye then
		d# 3 >d S" foo" >d >d strEql d> 0=if S"   splitBlort: prefix" >d >d type cr bye then
		d> d# 5 xor if S"   splitBlort: suffix length" >d >d type cr bye then
		d# 5 >d S" blort" >d >d strEql d> 0=if S"   splitBlort: suffix" >d >d type cr bye then
	S" foo/blort/" >d >d strSplitSlash
		d> d# 3 xor if S"   splitBlort: prefix length" >d >d type cr bye then
		d# 3 >d S" foo" >d >d strEql d> 0=if S"   splitBlort: prefix" >d >d type cr bye then
		d> d# 6 xor if S"   splitBlort: suffix length" >d >d type cr bye then
		d# 6 >d S" blort/" >d >d strEql d> 0=if S"   splitBlort: suffix" >d >d type cr bye then ;

: strTest
	S" str:" >d >d type cr
	strTSplitEmpty strTSplitSlash strTSplitBlort
	S" OK" >d >d type cr ;

\ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

\ ObjEnt objects bind a name to an STS object of some kind.
\ +0	Name
\ +8	Name Length
\ +16	Pointer to next entity
\ +24	Pointer to object

32 const szObjEnt

\ Initializes an object entry to default state.

: objEntInit ( a -- a )
	0 d@ >d  szObjEnt >d  zermem ;

\ Answers the length of the name for the entity.

: objEntNameLength ( a -- n )
	d> d# 8 + @ >d ;

\ Answers the pointer to the entity name.

: objEntNamePtr ( a -- a' )
	d> @ >d ;

\ Answers the next object in the entity chain, if any.

: objEntNext ( a -- a' )
	d> d# 16 + @ >d ;

\ Answers the object that the entity names.

: objEntObject ( a -- a' )
	d> d# 24 + @ >d ;

\ Sets the object that the entity binds.

: objEntSetObject ( a' a -- )
	d> d# 24 + d> swap ! ;

\ Creates a new entity.

: objEntNew ( -- a -1 | ? 0 )
	szObjEnt >d getmem 0 d@ 0=if exit then d> 
	objEntInit d# -1 >d ;

\ Disposes of an entity allocated by objEntNew.

: objEntDispose ( a -- )
	0 d@ @ if 0 d@ @ >d fremem then	( free name )
	fremem ;

\ Changes the name of the entity.
\ NOTE: Currently, you are responsible for freeing the original
\ name.  Changing the name without doing so will leak memory.

: objEntSetName ( caddr u a -- -1 | 0 )
	1 d@ 0 d@ d# 8 + !	( set length )
	2 d@ >d 2 d@ >d strDup d> 0=if
		d> d> d> d>
		d# 0 >d exit
	then
	d> d> !		( set name pointer )
	d> d> d# -1 >d ;

\ Answers the name of the entity.

: objEntName ( a -- caddr u )
	0 d@ >d objEntNameLength
	1 d@ @ 1 d! ;

\ Answers true if the entity possesses the given name.

: objEntIsNamed ( caddr u a -- -1 | 0 )
	objEntName strEql ;

: objEntTCreation
	objEntNew 0 d@ 0=if S"   creation: failed" >d >d type cr bye then d>
	objEntDispose ;

: _testName
	S" testName" >d >d ;

: objEntTName
	objEntNew 0 d@ 0=if S"   name: creation" >d >d type cr bye then d>
	_testName 2 d@ >d objEntSetName d> 0=if S"   name: set name" >d >d type cr bye then
	0 d@ >d objEntName
		d> d# 8 xor if S"   name: length mismatch" >d >d type cr bye then
		_testName d> d> d> xor 0=if S"   name: not copied" >d >d type cr bye then
	0 d@ >d objEntName _testName strEql d> 0=if S"   name: not equal" >d >d type cr bye then
	objEntDispose ;

: objEntTest
	S" ObjEnt:" >d >d type cr
	objEntTCreation objEntTName
	S" OK" >d >d type cr ;

\ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

\ Obj objects represent generic filing system objects in a
\ unified name space.  ObjEnt structures refer to instances of
\ Obj.  Depending on the nature of the object, they could be
\ ObjDir, ObjFile, or some other Obj-derived entity.  Note that
\ Obj *itself* is abstract, and cannot be instantiated in any
\ meaningful sense on its own.  See ObjDir (below) for one way
\ to refine Obj into something reifiable.

\ Obj objects consist of a single field: a pointer to a jump
\ table.

8 const szObj

\ Answers the object's jump table.

: objVTable ( a -- a' )
	d> @ >d ;

\ Walks the object hierarchy by name, and if the named resource is
\ found, return it and a true flag.  Otherwise, return a false flag.
\
\ Note that this procedure is recursive; it uses memory in proportion
\ to the depth of the sought resource.  If the object tree is
\ malformed so that a cycle exists, this procedure will overflow your
\ stack and crash the system.

: objWalk ( caddr u a -- a' -1 | ? 0 )
	0 d@ >d objVTable call ;

\ Disposes of the object.

: objDispose ( a -- )
	0 d@ >d objVTable d> d# 4 + >d call ;

\ Opens the resource.  If successful, an SCB is returned to the user.
\ Otherwise a failure flag is returned.

: objOpen ( a -- scb 0 | ? errcode )
	0 d@ >d objVTable d> d# 8 + >d call ;

\ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

\ ObjDir objects map names to other (compatible) objects.  These
\ form the basis for STS' filesystem abstraction.  They are
\ essentially singly-linked lists of name->object pairs that
\ happens to also know which ObjDir is its container.
\ 
\ +0	VTable
\ +8	Parent
\ +16	Pointer to first ObjEnt record, or NULL.

24 const szObjDir

\ Answers the directory's parent.  If the directory is the root
\ directory, it will answer itself.

: objDirParent ( a -- a' )
	d> d# 8 + @ >d ;

\ Assigns the object a new parent.  Objects can belong to only 
\ one parent.

: objDirSetParent ( p a -- )
	d> d# 8 + d> swap ! ;

\ Answers the first ObjEnt assigned to the directory.

: objDirFirst ( a -- a' )
	d> d# 16 + @ >d ;

\ Objects are polymorphic in some circumstances.  The following
\ jump table provides linkage to the methods corresponding to
\ object messages of similar names.

jump-table: objDir_vtable
jump-entries: objDirWalk objDirDispose objDirOpen ;

\ Attempt to open a directory should return ErrIsIterable.

: objDirOpen ( a -- ? ErrIsIterable )
	ErrIsIterable >d ;

\ Initializes an ObjDir.

: objDirInit ( a -- a )
	0 d@ >d szObjDir >d zermem
	objDir_vtable d> 0 d@ !				( vtable )
	0 d@ >d 0 d@ >d objDirSetParent ;		( we're a root directory )

\ Creates a new ObjDir directory object.  By default, it assumes
\ it's a root directory.  Use objDirSetParent to change this.

: objDirNew ( -- a -1 | ? 0 )
	szObjDir >d getmem 0 d@ 0=if exit then d>
	objDirInit d# -1 >d ;

\ Disposes of the object directory.  You should remove all
\ mounts before calling this procedure, or you will leak
\ memory.

: objDirDispose ( a -- )
	fremem ;

\ Adds an ObjEnt to the head of the ObjDir's list of bindings.

: objDirAddHead ( e a -- )
	0 d@ >d objDirFirst d> 1 d@ d# 16 + !	( set next field )
	d> d# 16 + d> swap ! ;

\ Removes an ObjEnt from the head of the ObjDir's binding list.

: objDirRemHead ( a -- a' )
	0 d@ >d objDirFirst
	0 d@ >d objEntNext  d> 1 d@ d# 16 + !
	d> 0 d! ;

\ Walks the object hierarchy by name, and if the named resource is
\ found, return it and a true flag.  Otherwise, return a false flag.
\
\ Note that this procedure is recursive; it uses memory in proportion
\ to the depth of the sought resource.  If the object tree is
\ malformed so that a cycle exists, this procedure will overflow your
\ stack and crash the system.

: objDirWalk ( caddr u a -- a' -1 | ? 0 )
	1 d@ 0=if	( null name? )
		0 d@ 2 d!  d# -1 1 d!  d>  exit
	then
	objDirFirst  2 d@ >d  2 d@ >d  strSplitSlash ( caddr u e sa su pa pu )
	begin 4 d@ while
		1 d@ >d 1 d@ >d 6 d@ >d objEntIsNamed d> if
			3 d@ 6 d!  2 d@ 5 d!
			d> d> d> d>
			objEntObject objWalk exit
		then
		4 d@ >d objEntNext d> 4 d!
	repeat d# 0 5 d! d> d> d> d> d> ;

: objDirTCreate
	objDirNew d> 0=if S"   create: failed" >d >d type cr bye then
	objDirDispose ;

: objDirTParent
	objDirNew d> 0=if S"   parent: creation" >d >d type cr bye then
	0 d@ >d objDirParent d> 0 d@ xor if S"   parent: expected root dir" >d >d type cr bye then
	objDirDispose ;

: objDirTEmpty
	objDirNew d> 0=if S"  empty: creation" >d >d type cr bye then
	0 d@ >d objDirFirst d> if S"   empty: content unexpected" >d >d type cr bye then
	objDirDispose ;

: objDirTFirst
	objDirNew d> 0=if S"   first: creation" >d >d type cr bye then
	objEntNew d> 0=if S"   first: entity" >d >d type cr bye then
	S" woohoo" >d >d 2 d@ >d objEntSetName d> 0=if S"   first: entity name" >d >d type cr bye then
	h# DEADBEEF >d 1 d@ >d objEntSetObject
	0 d@ >d 2 d@ >d objDirAddHead

	1 d@ >d objDirFirst d> 0 d@ xor if S" first: mismatch" >d >d type cr bye then
	1 d@ >d objDirRemHead d>
	objEntDispose objDirDispose ;

: objDirTWalk1
	objDirNew d> 0=if S"   walk: dir" >d >d type cr bye then

	objDirNew d> 0=if S"   walk: subdir" >d >d type cr bye then
	1 d@ >d 1 d@ >d objDirSetParent

	objEntNew d> 0=if S"   walk: ent" >d >d type cr bye then
	S" woo" >d >d 2 d@ >d objEntSetName d> 0=if S"   walk: ent name" >d >d type cr bye then
	1 d@ >d 1 d@ >d objEntSetObject
	0 d@ >d 3 d@ >d objDirAddHead

	_emptystr 4 d@ >d objDirWalk
		d> 0=if S" walk: can't find self" >d >d type cr bye then
		d> 2 d@ xor if S"   walk: self expected" >d >d type cr bye then
	S" woo" >d >d 4 d@ >d objDirWalk
		d> 0=if S" walk: can't find woo" >d >d type cr bye then
		d> 1 d@ xor if S"   walk: woo expected" >d >d type cr bye then
	S" bar" >d >d 4 d@ >d objDirWalk
		d> if S" walk: missing file found?" >d >d type cr bye then
		d>

	objEntDispose objDirDispose objDirDispose ;
	
: objDirTWalk3
	objDirNew d> 0=if S"   walk3: dir" >d >d type cr bye then
	h# DEADBEEF >d h# FEEDFACE >d S" foobar" >d >d 4 d@ >d objWalk
	d> if S"   walk3: failure expected" >d >d type cr bye then
	d>
	d> h# FEEDFACE xor if S"   walk3: stack imbalance 1" >d >d type cr bye then
	d> h# DEADBEEF xor if S"   walk3: stack imbalance 2" >d >d type cr bye then
	objDispose ;

: objDirTWalk2
	\ Construct the following object tree:
	\
	\ root
	\   sd1
	\   sd2
	\      sd3
	\         sd4

	objDirNew d> 0=if S"   walk2: root" >d >d type cr bye then
	objDirNew d> 0=if S"   walk2: subdir1" >d >d type cr bye then
	objDirNew d> 0=if S"   walk2: subdir2" >d >d type cr bye then
	objDirNew d> 0=if S"   walk2: subdir3" >d >d type cr bye then
	objDirNew d> 0=if S"   walk2: subdir4" >d >d type cr bye then

	( root sd1 sd2 sd3 sd4 )

	4 d@ >d 4 d@ >d objDirSetParent
	4 d@ >d 3 d@ >d objDirSetParent
	2 d@ >d 2 d@ >d objDirSetParent
	1 d@ >d 1 d@ >d objDirSetParent

	objEntNew d> 0=if S"   walk2: e1" >d >d type cr bye then
	objEntNew d> 0=if S"   walk2: e2" >d >d type cr bye then
	objEntNew d> 0=if S"   walk2: e3" >d >d type cr bye then
	objEntNew d> 0=if S"   walk2: e4" >d >d type cr bye then

	( root sd1 sd2 sd3 sd4 e1 e2 e3 e4 )
	
	S" sd1" >d >d 5 d@ >d objEntSetName d> 0=if S"   walk2: name sd1" >d >d type cr bye then
	S" sd2" >d >d 4 d@ >d objEntSetName d> 0=if S"   walk2: name sd2" >d >d type cr bye then
	S" sd3" >d >d 3 d@ >d objEntSetName d> 0=if S"   walk2: name sd3" >d >d type cr bye then
	S" sd4" >d >d 2 d@ >d objEntSetName d> 0=if S"   walk2: name sd4" >d >d type cr bye then

	7 d@ >d 4 d@ >d objEntSetObject
	6 d@ >d 3 d@ >d objEntSetObject
	5 d@ >d 2 d@ >d objEntSetObject
	4 d@ >d 1 d@ >d objEntSetObject

	3 d@ >d 9 d@ >d objDirAddHead
	2 d@ >d 9 d@ >d objDirAddHead
	1 d@ >d 7 d@ >d objDirAddHead
	0 d@ >d 6 d@ >d objDirAddHead

	S" sd2/sd3/sd4" >d >d 10 d@ >d objWalk
		d> 0=if S"   walk2: can't find sd4" >d >d type cr bye then
		d> 4 d@ xor if S"   walk2: sd4 expected" >d >d type cr bye then

	objEntDispose objEntDispose objEntDispose objEntDispose
	objDispose objDispose objDispose objDispose objDispose ;

: objDirTest
	S" objdir:" >d >d type cr
	objDirTCreate objDirTParent objDirTEmpty objDirTFirst objDirTWalk1 objDirTWalk2 objDirTWalk3
	S" OK" >d >d type cr ;

\ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\ ROM-resident "files" are just binary blobs stored in ROM,
\ with descriptors to record their location.  Really, they're
\ not much more sophisticated than strings.
\
\ +0	vtable
\ +8	base pointer of binary data
\ +16	length of binary data in bytes
\
\ ROM-resident files which are opened have their own SCBs.
\ 
\ +0	vtable
\ +8	rom file pointer
\ +16	read index

( Placed here to eliminate circular dependency. )
: romFileGetContents ( a -- caddr u )
	0 d@ d# 16 + @ >d  1 d@ d# 8 + @ 1 d! ;

24 const szRomScb

jump-table: romScb_vtable
jump-entries: romScbDispose romScbRead romScbSize romScbSeek ;

: romScbSeek ( pos a -- a' 0 | ? errcode )
	0 d@ d# 8 + @ d# 16 + @   1 d@ - -if  ErrTooBig 0 d! exit then
	0 d@ d# 16 + @
		1 d@  0 d@ d# 16 + !
	1 d!  d# 0 0 d! ;

: romScbSize ( a -- n )
	d> d# 8 + @ >d romFileGetContents 0 d@ 1 d! d> ;

: romScbNew ( -- a -1 | ? 0 )
	szRomScb >d getmem d> 0=if d# 0 exit then
	0 d@ >d  szRomScb >d  zermem
	romScb_vtable d> 0 d@ !
	d# -1 >d ;

: romScbDispose ( a -- )
	fremem ;

: romScbSetFile ( scb a -- )
	1 d@ 0 d@ d# 8 + !  d> d> ;

: romScbRead ( caddr u scb -- actual errCode )
	0 d@ d# 8 + @ >d romFileGetContents	( caddr u scb base len )
	2 d@ d# 16 + @ 3 d@ +  0 d@ d# 1 +  -  -if
		1 d@ 2 d@ d# 16 + @ + >d
		5 d@ >d
		5 d@ >d movmem
		2 d@ d# 16 + @  3 d@ +  2 d@ d# 16 + !
		3 d@ 4 d!  d# 0 3 d!
		d> d> d> exit
	then
	0 d@  2 d@ d# 16 + @  -  3 d! d> d> romScbRead ;

24 const szRomFile

jump-table: romFile_vtable
jump-entries: romFileWalk fremem romFileOpen ;

: romFileWalk ( caddr u a -- a' -1 | ? 0 )
	1 d@ 0=if  0 d@ 2 d!  d# -1 1 d!  d> exit then
	d# 0 1 d! d> exit ;

: romFileSetContents ( caddr u a -- )
	2 d@ 0 d@ d# 8 + !   1 d@ 0 d@ d# 16 + !  d> d> d> ;

: romFileOpen ( a -- scb 0 | ? errcode )
	romScbNew d> 0=if ErrNoMemory >d exit then
	1 d@ >d 1 d@ >d romScbSetFile
	0 d@ 1 d! d# 0 0 d! ;

: romFileNew ( -- a -1 | ? 0 )
	szRomFile >d getmem d> 0=if d# 0 >d exit then
	0 d@ >d szRomFile >d zermem
	romFile_vtable d> 0 d@ !
	d# -1 >d ;

\ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

\ The filesystem interface is responsible for maintaining an
\ in-memory description of the current filesystem layout, as
\ well as providing methods of accessing resources in the
\ filesystem.

\ open attempts to resolve the given filename to a resource,
\ and asks the resource to create a new connection to it.
\ If successful, a stream control block (SCB) is returned to
\ the caller; otherwise, a nil result is returned, along with
\ an error code.

dword: rootnode

: open ( caddr u -- scb 0 | ? errcode )
	0 d@ 0=if ErrNotFound 0 d! exit then
	1 d@ c@  char / lit,  xor if ErrRelative 0 d! exit then
	1 d@ d# 1 + 1 d!  0 d@ d# 1 - 0 d!	( eat the / )
	rootnode @ >d objWalk
	d> 0=if ErrNotFound >d exit then
	objOpen ;

\ SCBs have different implementations completely; they're opaque
\ data types as far as the client is concerned.  However, they
\ all share one thing in common: the layout of their v-table.
\ 
\ +0	close	( scb -- )
\ +4	read	( caddr u scb -- actual errcode )
\ +8	filsiz	( scb -- file-size )
\ +12	seek	( offset scb -- oldpos errcode )

: scbVTable ( a -- a' )
	objVTable ;

\ close releases the resources acquired by a preceding open call.
\ This can never fail.

: close ( scb -- )
	0 d@ >d scbVTable call ;

\ Read in the next sequence of bytes from the resource represented
\ by the SCB.  If the resource is not readable, an error will result.
\ Otherwise, the actual number of bytes read will be returned.
\ If 0 bytes are returned, you may be at the end of the stream.

: read ( caddr u scb -- actual 0 | ? errcode )
	0 d@ >d scbVTable d> d# 4 + >d call ;

\ Determine the size of a file without changing the read/write pointer.

: filsiz ( scb -- n )
	0 d@ >d scbVTable d> d# 8 + >d call ;

\ Seeks to a spot in the file.

: seek ( offset scb -- oldpos 0 | ? errcode )
	0 d@ >d scbVTable d> d# 12 + >d call ;

\ Unloads a program from memory.

: unloadseg ( seg -- )
	0 d@ d# 16 - 0 d! fremem ;

\ Load a set of program segments into memory, and if required
\ for the executable format, perform appropriate relocations
\ so that the loaded code may be executable in-place.
\ 
\ If successful, a reference to the first (of potentially many)
\ segments will be returned, along with a success code of zero.
\ Otherwise, the segment reference is undefined, and an error
\ code is returned.
\ 
\ Note that the segment reference returned points to the first
\ actual byte of data or code.  Segment-specific linkage appears
\ at negative offsets from this reference.

: loadseg ( caddr u -- seg 0 | ? errcode )
	open 0 d@ if exit then d>
	0 d@ >d filsiz  ( h fsize )
	0 d@ d# 16 + >d getmem d> 0=if
		( h fsize ? )
		2 d@ 0 d! close
		ErrNoMemory 0 d! exit
	then
	( h fsize seg )
	d# 0 0 d@ !		( next link is null )
	1 d@ 0 d@ d# 8 + !	( size of segment data )
	0 d@ d# 16 + 0 d!	( refer to the data bytes from now on )

	0 d@ >d 2 d@ >d 4 d@ >d read
	( h fsize seg actual flag )
	0 d@ if
		d> 2 d! d> unloadseg 1 d@ >d close exit
	then d>
	0 d@ 2 d@ xor if
		ErrTooBig 2 d! d> unloadseg 1 d@ >d close exit
	then d>
	0 d@ @32 h# 8067 ( JALR X0, 0[X1] ) xor if
		ErrNotExec 1 d! unloadseg 1 d@ >d close exit
	then
	2 d@ >d close
	0 d@ 2 d!  d# 0 1 d!  d> ;

: fsTOpenDir
	objDirNew d> 0=if S"   opendir: root dir" >d >d type cr bye then
	d> rootnode !

	objDirNew d> 0=if S"   opendir: subdir" >d >d type cr bye then
	rootnode @ >d 1 d@ >d objDirSetParent
	objEntNew d> 0=if S"   opendir: subdir name" >d >d type cr bye then
	S" aDir" >d >d 2 d@ >d objEntSetName d>
	1 d@ >d 1 d@ >d objEntSetObject
	0 d@ >d rootnode @ >d objDirAddHead

	_emptystr open d> ErrNotFound xor if S"   opendir: how to find unnamed file?" >d >d type cr bye then d>
	S" aDir" >d >d open d> ErrRelative xor if S"   opendir: only absolute names" >d >d type cr bye then d>
	S" /aDir" >d >d open d> ErrIsIterable xor if S"   opendir: dirs are iterables" >d >d type cr bye then d>

	objEntDispose objDispose  rootnode @ >d objDispose ;

word: dummy_hdr

: fsTOpenFileSetup
	objDirNew d> 0=if S"   openfil: root dir" >d >d type cr bye then
	d> rootnode !

	romFileNew d> 0=if S"   openfil: file" >d >d type cr bye then
	S" 0123456789ABCDEF" >d >d 2 d@ >d romFileSetContents

	objEntNew d> 0=if S"   openfil: filename" >d >d type cr bye then
	S" aFile" >d >d 2 d@ >d objEntSetName d>
	1 d@ >d 1 d@ >d objEntSetObject
	0 d@ >d rootnode @ >d objDirAddHead

	romFileNew d> 0=if S"   openfil: exec" >d >d type cr bye then
	dummy_hdr >d d# 4 >d 2 d@ >d romFileSetContents
	h# 8067 dummy_hdr !

	objEntNew d> 0=if S"   openfil: execname" >d >d type cr bye then
	S" anExe" >d >d 2 d@ >d objEntSetName d>
	1 d@ >d 1 d@ >d objEntSetObject
	0 d@ >d rootnode @ >d objDirAddHead ;

: fsTOpenFileCleanup
	objEntDispose objDispose objEntDispose objDispose rootnode @ >d objDispose ;

: fsTSeekFile
	fsTOpenFileSetup
	S" /aFile" >d >d open d> if S"   seek: open" >d >d type cr bye then

	d# 6 >d 1 d@ >d seek d> if S"   seek: seek" >d >d type cr bye then
	d> d# 0 xor if S"   seek: old position" >d >d type cr bye then

	h# FF0000 >d d# 5 >d 2 d@ >d read
	d> if S"   seek: should have worked" >d >d type cr bye then
	d> d# 5 xor if S"   seek: length mismatch" >d >d type cr bye then

	h# FF0000 >d d# 5 >d
	S" 6789A" >d >d strEql d> 0=if S"   seek: bytes mismatch" >d >d type cr bye then

	d# 0 >d 1 d@ >d seek d> if S"   seek: rewind" >d >d type cr bye then
	d> d# 11 xor if S"   seek: rewind old pos" >d >d type cr bye then

	d# 100 >d  1 d@ >d  seek d>  0=if S"   seek: bounds" >d >d type cr bye then d>

	close fsTOpenFileCleanup ;

: fsTOpenFile
	fsTOpenFileSetup
	S" /aFile" >d >d open d> if S"   openfil: file should have opened" >d >d type cr bye then

	( WARNING: I'm going to corrupt MGIA frame buffer space here. )
	( I can do this because self-tests run BEFORE the OS actually boots. )

	h# FF0000 >d d# 5 >d 2 d@ >d read
	d> if S"   openfil: read 1: should have worked" >d >d type cr bye then
	d> d# 5 xor if S"   openfil: read 1: length mismatch" >d >d type cr bye then
	h# FF0000 >d d# 5 >d S" 01234" >d >d strEql d> 0=if S"   openfil: read 1: bytes mismatch" >d >d type cr bye then

	h# FF0000 >d d# 5 >d 2 d@ >d read
	d> if S"   openfil: read 2: should have worked" >d >d type cr bye then
	d> d# 5 xor if S"   openfil: read 2: length mismatch" >d >d type cr bye then
	h# FF0000 >d d# 5 >d S" 56789" >d >d strEql d> 0=if S"   openfil: read 2: bytes mismatch" >d >d type cr bye then

	h# FF0000 >d d# 5 >d 2 d@ >d read
	d> if S"   openfil: read 3: should have worked" >d >d type cr bye then
	d> d# 5 xor if S"   openfil: read 3: length mismatch" >d >d type cr bye then
	h# FF0000 >d d# 5 >d S" ABCDE" >d >d strEql d> 0=if S"   openfil: read 3: bytes mismatch" >d >d type cr bye then

	h# FF0000 >d d# 5 >d 2 d@ >d read
	d> if S"   openfil: read 4: should have worked" >d >d type cr bye then
	d> d# 1 xor if S"   openfil: read 4: length mismatch" >d >d type cr bye then
	h# FF0000 >d d# 1 >d S" F" >d >d strEql d> 0=if S"   openfil: read 4: bytes mismatch" >d >d type cr bye then

	close fsTOpenFileCleanup ;

: fsTLoadSeg
	fsTOpenFileSetup
	S" /anExe" >d >d loadseg
	d> if S"   loadseg: expected to work" >d >d type cr bye then
	unloadseg fsTOpenFileCleanup ;

: fsTest
	S" fs:" >d >d type cr
	fsTOpenDir fsTOpenFile fsTLoadSeg fsTSeekFile
	S" ok" >d >d type cr ;

\ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\ Libraries are (disk-)resident collections of related programs,
\ identifiable under a unique name, and intended to be used by
\ other programs and libraries.  Libraries are expected to
\ follow semantic versioning practices.  The name of the library
\ includes the major version number as the lowest level
\ qualifier.  For example, "sts.blitter.1" identifies the standard
\ blitter library, major version 1.  This is just a naming
\ convention, but when used with minorVersion, you'll see its value.
\ 
\ Libraries are also identified by their minor version level
\ as well.  While the major version must match precisely, being
\ a part of the name of the library, a library will be compatible
\ with an application if its minor version is greater than or
\ equal to that requested by an application.
\
\ Libraries are kept in a linked list, and managed by STS.
\ A Library Control Block looks like this:
\ 
\ +0	Next
\ +8	Segment pointer
\ +16	Jump table pointer
\ +24	Minor version
\ +32	Name length
\ +40	Name
\ +48	Open counter

\ 56 bytes total

dword: liblist

\ Find a library by name and minor version.
\ If the named library cannot be found, then return ErrNotFound.
\ If the named library can be found, but yet doesn't meet the minimum
\ version requirement, continue scanning for another candidate library;
\ if none remains, return ErrNotFound.
\ Otherwise, return the library's handle.

: fndlib ( caddr u n -- hlib 0 | ? erc )
	liblist @ >d  ( caddr u n ll )
	begin	0 d@ liblist xor
	while	3 d@ >d 3 d@ >d  ( caddr u n ll caddr u )
		2 d@ d# 40 + @ >d  ( caddr u n ll caddr u nam )
		3 d@ d# 32 + @ >d  ( caddr u n ll caddr u nam namlen )
		strEql  ( caddr u n ll eqf )
		d>
		if	0 d@ d# 24 + @  1 d@ -
			+if	0 d@ 3 d! d# 0 2 d! d> d> exit
			then
		then
		0 d@ @ 0 d!
	repeat
	ErrNotFound 2 d! d> d> ;

\ Makes a library known to the rest of the STS environment.
\ The library name is NOT checked for uniqueness, for it is
\ conceivable that different implementations corresponding
\ to different versions can be loaded concurrently.  However,
\ this is not a recommended practice, and is left only for
\ advanced users.
\
\ The jump table must point to a dword-aligned set of JAL
\ instructions, like so:
\ 
\	JAL X0, openHandler
\	JAL X0, closeHandler
\	JAL X0, expungeHandler
\	JAL X0, reservedHandler
\	JAL X0, myFunction1
\	JAL X0, myFunction2
\	JAL X0, myFunction3
\	JAL X0, myFunction4
\	...etc...
\
\ The first entry is invoked by STS itself when a library
\ is opened with `getlib`.  This procedure must return an
\ error code; the library will be opened only when the
\ error code is zero.
\
\ `closeHandler` is invoked when the client application
\ calls `rellib`.  Every successful open attempt must have
\ a corresponding close attempt.  Closing a library cannot
\ fail.
\ 
\ `expungeHandler` is invoked when STS realizes that the
\ library has no current users, and is prepared to unload
\ the library from memory.  Its purpose is to undo any
\ global initializations that took place when the library
\ was first loaded.  Like `closeHandler`, it cannot fail.
\
\ The segment pointer must be non-zero for libraries loaded
\ from storage.  Only ROM-resident libraries may have a
\ zero segment pointer.
\
\ If the registration attempt is successful, the library
\ will have an open count of *zero*, but STS will not yet
\ unload the library.  This gives a client application
\ a chance to use it (presuming that addlib was invoked by
\ getlib).
\
\ If successful, a handle to the library is returned.
\ Otherwise, a relevant error code is returned.

: addlib ( caddr u n jumptab segptr -- hlib 0 | ? erc )
	d# 56 >d getmem d> if
		( caddr u n jumptab segptr hlib )
		1 d@ 0 d@ d# 8 + !
		2 d@ 0 d@ d# 16 + !
		3 d@ 0 d@ d# 24 + !
		4 d@ 0 d@ d# 32 + !
		5 d@ >d 5 d@ >d strDup d> if
			( caddr u n jumptab segptr hlib caddr' )
			0 d@ 1 d@ d# 40 + !
			d# 0 1 d@ d# 48 + !
			liblist @ 1 d@ !  1 d@ liblist !
			d> d> d> d> d>
			liblist @ 1 d!  d# 0 0 d! exit
		then

		\ If we're here, we couldn't duplicate the name;
		\ out of memory.  Sorry.  :(

		1 d@ >d fremem
		d> d> d> d> d>
		ErrNoMemory 0 d!
	else
		ErrNoMemory 4 d!
		d> d> d> d>
	then ;

\ rmvlib attempts to remove a library and unload the program backing it.
\ If it is not possible to perform this action, a suitable error
\ response is given (e.g., ErrInUse).  Otherwise, if successful,
\ zero is returned.

: rmvlib ( hlib -- erc )
	\ Find hlib in list, and remove it if possible.
	\ Keep track of both predecessor and current node pointers
	\ (pp and ll, respectively) along the way.
	\ If the node is found, then set predecessor's next link
	\ to the found node's next link, thus removing the node
	\ from the list.  Then, dispose of the node.
	liblist >d liblist @ >d ( hlib pp ll )
	begin	0 d@ liblist xor
	while	0 d@ 2 d@ xor
		0=if	0 d@ d# 48 + @
			if	ErrInUse 2 d! d> d> exit
			then

			0 d@ @  1 d@ !			( pred->next = succ )
			0 d@ d# 40 + @ >d fremem	( free the duplicated name )
			0 d@ >d fremem			( free the node itself )
			d> d> d# 0 0 d! exit
		then
		0 d@ @ 0 d!
		1 d@ @ 1 d!
	repeat
	ErrNotFound 0 d! ;

: getlib ( caddr u n -- jt hlib 0 | ? ? erc )
	fndlib
	0 d@ if 0 d@ >d exit then d>
	0 d@ d# 16 + @ >d call	( invoke open handler )
	0 d@ if 0 d@ >d exit then
	( hlib 0 )
	0 d@ >d  2 d@ 1 d!  1 d@ d# 16 + @ 2 d!		( jt hlib 0 )
	1 d@ d# 48 + @  d# 1 +  1 d@ d# 48 + ! ;

: rellib ( hlib -- erc )
	0 d@ d# 48 + @
	if	0 d@ d# 16 + @ d# 4 + >d call	( call close handler )
		0 d@ d# 48 + @ d# -1 +  0 d@ d# 48 + !  ( decrement open count )
	then 
	0 d@ d# 48 + @
	0=if	0 d@ d# 16 + @ d# 8 + >d call	( call expunge handler )
		rmvlib exit
	then
	d# 0 0 d! ;

dword: libTopenCalled
dword: libTcloseCalled
dword: libTexpungeCalled

: libTopen ( -- erc )	d# 0 >d  d# 1 libTopenCalled ! ;
: libTclose ( -- )	d# 1 libTcloseCalled ! ;
: libTexpunge ( -- )	d# 1 libTexpungeCalled ! ;
: libTzero ( -- 0 )	d# 0 >d ;
: libTcustom ( -- )	d# 2 libTopenCalled ! ;

jump-table: lib_null_jt
jump-entries: libTopen libTclose libTexpunge libTzero libTcustom ;

: libTfndlib
	S" sts.test.1" >d >d d# 0 >d fndlib
	d> ErrNotFound xor if S"   fnd: test not added yet" >d >d type cr bye then
	d> ;

: libTaddlib
	S" sts.test.2" >d >d d# 1 >d lib_null_jt h# 0 >d addlib
	d> if S"   add: unexpected error adding" >d >d type cr bye then
	liblist @ liblist xor 0=if S"   add: adding node didn't update list header" >d >d type cr bye then

	( hlib )

	S" sts.test.2" >d >d d# 0 >d fndlib
	d> if S"   add: added library cannot be found" >d >d type cr bye then
	d> d> xor if S"   add: found library handle != added handle" >d >d type cr bye then

	S" sts.test.2" >d >d d# 3 >d fndlib
	d> 0=if S"   add: lib not new enough" >d >d type cr bye then d> ;

: libTrmvlib
	S" sts.test.2" >d >d d# 0 >d fndlib ( from previous test )
	d> if S"   rmv: not supposed to error out here" >d >d type cr bye then
	rmvlib
	d> if S"   rmv: lib removal not supposed to error" >d >d type cr bye then
	S" sts.test.2" >d >d d# 0 >d fndlib
	d> 0=if S"   rmv: Removed library wasn't removed." >d >d type cr bye then d> ;

: libTrmv2
	S" sts.test.3" >d >d d# 1 >d lib_null_jt h# 0 >d addlib
	d> if S"   rmv2: unexpected error adding" >d >d type cr bye then
	d# 1 0 d@ d# 48 + !
	0 d@ >d rmvlib d> ErrInUse xor if S"   rmv2: library still in use" >d >d type cr bye then
	d# 0 0 d@ d# 48 + !
	rmvlib d> if S"   rmv2: library no longer in use" >d >d type cr bye then ;

: libTget
	d# 0 libTopenCalled !  d# 0 libTcloseCalled !  d# 0 libTexpungeCalled !
	S" sts.null.1" >d >d d# 1 >d lib_null_jt h# 0 >d addlib d> ( hlib )

	S" sts.null.1" >d >d d# 1 >d getlib ( hlib  jt hlib erc )
	d> if S"   get: unexpected failure trying to open rom-resident library" >d >d type cr bye then
	d> 1 d@ xor if S"   get: expected same library" >d >d type cr bye then
	libTopenCalled @ 0=if S"   get: open didn't get called" >d >d type cr bye then
	d> d# 16 + >d call
	libTopenCalled @ d# 2 xor if S"   get: incorrect jumptable?" >d >d type cr bye then
	0 d@ >d rmvlib d> 0=if S"   get: removal of in-use lib" >d >d type cr bye then

	rellib d> if S"   get: rellib failed" >d >d type cr bye then
	libTcloseCalled @ 0=if S"   get: close didn't get called" >d >d type cr bye then
	libTexpungeCalled @ 0=if S"   get: expunge didn't get called" >d >d type cr bye then ;

: libTgetbad
	S" sts.null.2" >d >d d# 0 >d getlib ( ? ? erc )
	d> 0=if S"  getbad: unknown library successful?" >d >d type cr bye then d> d> ;

: libTest
	S" lib:" >d >d type cr
	liblist liblist !
	libTfndlib libTaddlib libTrmvlib libTrmv2
	libTget libTgetbad
	S" ok" >d >d type cr ;

\ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

\ The ROM-resident shell.  Eventually, this will be placed into
\ an executable that resides in the ROM filesystem.  From there,
\ it will eventually find its way onto removable media (e.g.,
\ disk or SD card).  The shell is present in ROM only for debug
\ and bootstrapping purposes.

( Some utilities which I think will become official STS procedures )

\ Returns non-zero if a getkey will not block, implying a valid
\ character is available for reading.  Zero is returned otherwise.
\
\ polkey ( -- flag )

\ : polkey	h# 0E00000000000000 c@ >d ;

\ Blocks until a valid ASCII character has been received from the
\ user's keyboard.  This procedure bypasses the file I/O interface,
\ so use with caution.  Where possible, use the file I/O interface
\ instead.  Note that getkey does not offer a timeout!
\
\ getkey ( -- ch )

extern caninp	( replaces polkey; named after BIOS function it calls )
extern chrinp

: getkey	begin caninp d> if chrinp exit then again ;

\ Prints an arbitrary string to the user's console, then blocks forever.
\
\ panic ( caddr u -- )

: panic		type cr begin again ;


: title
  S"     #####     ######    #####  " >d >d type cr
  S"    ##   ##      ##     ##   ## " >d >d type cr
  S"   ##           ##     ##      " >d >d type cr
  S"    #####       ##      #####  " >d >d type cr
  S"       ##      ##          ## " >d >d type cr
  S"  ##   ##      ##     ##   ## " >d >d type cr
  S"  #####       ##      #####  " >d >d type cr
  S"                             " >d >d type cr
  S"           STS V1.5" >d >d type cr cr ;
: copyr		S" Copyright 2014-2015 Samuel A. Falvo II, et. al." >d >d type cr cr ;
: license
  S" This software is subject to the terms of the Mozilla Public License, v. 2.0." >d >d type cr
  S" If a copy of the MPL was not distributed with this file, you can obtain one at" >d >d type cr
  S" https://mozilla.org/MPL/2.0/ ." >d >d type cr ;

: ident		title copyr license ;
: prompt	S" > " >d >d type ;

\ Gap buffer implementation to accept user input.
\ NOTE: This is an incomplete port of the implementation used in Kestrel-2
\ because we don't have raw PS/2 keyboard access, nor a directly addressible
\ terminal at our disposal.  When I enhance the emulator, this will change,
\ and we can revise the input handling to facilitate better editing features.

dword: ls	( points at buffer )
dword: le	( points at beginning of gap )
dword: rs	( points at text following gap )
dword: re	( points just beyond last character )

: resetsh	ls @ le !  ls @ d# 160 + rs !  ls @ d# 160 + re ! ;
: nobuf		S" E01 Insufficient memory for shell input buffer." >d >d panic ;
: initsh	d# 160 >d getmem d> 0=if nobuf then d> ls ! resetsh ;

: lebump	le @ d# 1 - le ! ;
: bs		ls @ le @ xor if backspace space backspace lebump then ;
: bumple	le @ d# 1 + le ! ;
: bumprs	rs @ d# 1 + rs ! ;
: insert	0 d@ le @ c!  bumple ;
: graphic	le @ rs @ xor if insert 0 d@ emit then ;
: handle	0 d@ d# 8 xor 0=if bs exit then
		graphic ;
: collapse	rs @ c@ le @ c!  bumple bumprs ;
: finish	begin rs @ re @ xor 0=if exit then collapse again ;

\ Block until the user has finished entering a whole line of text.
\ The user can use backspace and DEL keys to correct errors.
\ Use CTRL-F and CTRL-B to cursor forward or backward.
\
\ Note that subsequent calls to this procedure WILL OVERWRITE the
\ contents of the buffer from last time, so if you need to preserve
\ the contents of the buffer, you must do so before calling accept
\ again.
\ 
\ accept ( -- caddr u )

: accept	resetsh begin getkey 0 d@ d# 10 xor 0=if d> finish ls @ >d le @ ls @ - >d exit then handle again ;

: unknown	S" : unknown command" >d >d type ;

\ Isolate the command in a command-line.  The original command string is not
\ altered in any way.
\ 
\ cmd ( caddr u -- caddr u caddr' u' )

: dropchar	d> d> d# 1 + >d d# 1 - >d ;

: skipws ( caddr u -- caddr' u' )
  begin	0 d@ 0=if exit then
	1 d@ c@ d# 33 - +if exit then
	dropchar
  again ;

: skipnws ( caddr u -- caddr' u' )
  begin	0 d@ 0=if exit then
	1 d@ c@ d# 33 - -if exit then
	dropchar
  again ;

: cmd		skipws 1 d@ >r skipnws 1 d@ 0 r@ - r> >d >d ;

: _write ;	( not implemented yet )

jump-table: sts_vt
jump-entries: getver ; ( version identification )
jump-entries: getmem fremem movmem setmem zermem ; ( memory management )
jump-entries: open close filsiz read _write seek ; ( file I/O )
jump-entries: loadseg unloadseg ; ( executable I/O )
jump-entries: strEql strDup strSplitSlash ; ( basic string library )
jump-entries: emit type cr space _64 caninp getkey ; ( console I/O )
jump-entries: fndlib addlib rmvlib getlib rellib ; ( libraries )

: romshell
  cr ident initsh
  begin	prompt accept cr cmd
	1 d@ >d 1 d@ >d loadseg d> if
		d> type unknown cr
	else
		( caddr u caddr' u' seg )
		d# 0 >d sts_vt
		2 d@ d# 8 + >d call
		d> d>
		unloadseg
		d> d>
	then
	d> d>
  again ;

\ Luke-warm boot.  After BSPL's start-up code completes, it jumps to _
\ (yes, that's a single underscore).  BSPL's runtime does not expect _ to
\ return.

: banner	S" Booting STS V1.5" >d >d type cr ;
: mem0		h# 8000 >d  d# 16777216 h# 18000 - >d fmtmem ;
		( Nexys2 has 16MB of on-board RAM, less 8K for low RAM, and 64K for MGIA framebuffer. )

extern prg_hello_start
extern prg_hello_len

extern prg_m2_start
extern prg_m2_len

extern prg_m2slides_start
extern prg_m2slides_len

extern prg_m2slidesRV3_start
extern prg_m2slidesRV3_len

extern prg_fbtest_start
extern prg_fbtest_len

extern prg_lbutest_start
extern prg_lbutest_len

extern prg_testblit_start
extern prg_testblit_len

extern img_kestrel_start
extern img_kestrel_len

extern prg_show_start
extern prg_show_len


: fs0
	objDirNew d> 0=if S" dir / failed" >d >d panic then
	d> rootnode !

	objDirNew d> 0=if S" dir /rom failed" >d >d panic then
	objEntNew d> 0=if S" ent /rom failed" >d >d panic then
	S" rom" >d >d 2 d@ >d objEntSetName d> 0=if S" nam /rom failed" >d >d panic then
	1 d@ >d 1 d@ >d objEntSetObject
	0 d@ >d rootnode @ >d objDirAddHead

	( root[dir ent] )

	romFileNew d> 0=if S" fil /rom/foo failed" >d >d panic then
	S" Hello" >d >d 2 d@ >d romFileSetContents
	objEntNew d> 0=if S" ent /rom/foo failed" >d >d panic then
	S" foo" >d >d 2 d@ >d objEntSetName d> 0=if S" nam /rom/foo failed" >d >d panic then
	1 d@ >d 1 d@ >d objEntSetObject
	0 d@ >d 4 d@ >d objDirAddHead
	d> d>

	romFileNew d> 0=if S" fil /rom/hello failed" >d >d panic then
	prg_hello_start prg_hello_len 2 d@ >d romFileSetContents
	objEntNew d> 0=if S" ent /rom/hello failed" >d >d panic then
	S" hello" >d >d 2 d@ >d objEntSetName d> 0=if S" nam /rom/hello failed" >d >d panic then
	1 d@ >d 1 d@ >d objEntSetObject
	0 d@ >d 4 d@ >d objDirAddHead
	d> d>

	romFileNew d> 0=if S" fil /rom/fbtest failed" >d >d panic then
	prg_fbtest_start prg_fbtest_len 2 d@ >d romFileSetContents
	objEntNew d> 0=if S" ent /rom/fbtest failed" >d >d panic then
	S" fbtest" >d >d 2 d@ >d objEntSetName d> 0=if S" nam /rom/fbtest failed" >d >d panic then
	1 d@ >d 1 d@ >d objEntSetObject
	0 d@ >d 4 d@ >d objDirAddHead
	d> d>

	romFileNew d> 0=if S" fil /rom/m2 failed" >d >d panic then
	prg_m2_start prg_m2_len 2 d@ >d romFileSetContents
	objEntNew d> 0=if S" ent /rom/m2 failed" >d >d panic then
	S" m2" >d >d 2 d@ >d objEntSetName d> 0=if S" nam /rom/m2 failed" >d >d panic then
	1 d@ >d 1 d@ >d objEntSetObject
	0 d@ >d 4 d@ >d objDirAddHead
	d> d>

	romFileNew d> 0=if S" fil /rom/m2.slides failed" >d >d panic then
	prg_m2slides_start prg_m2slides_len 2 d@ >d romFileSetContents
	objEntNew d> 0=if S" ent /rom/m2.slides failed" >d >d panic then
	S" m2.slides" >d >d 2 d@ >d objEntSetName d> 0=if S" nam /rom/m2.slides failed" >d >d panic then
	1 d@ >d 1 d@ >d objEntSetObject
	0 d@ >d 4 d@ >d objDirAddHead
	d> d>

	romFileNew d> 0=if S" fil /rom/m2.slides.riscv.3 failed" >d >d panic then
	prg_m2slidesRV3_start prg_m2slidesRV3_len 2 d@ >d romFileSetContents
	objEntNew d> 0=if S" ent /rom/m2.slides.riscv.3 failed" >d >d panic then
	S" m2.slides.riscv.3" >d >d 2 d@ >d objEntSetName d> 0=if S" nam /rom/m2.slides.riscv.3 failed" >d >d panic then
	1 d@ >d 1 d@ >d objEntSetObject
	0 d@ >d 4 d@ >d objDirAddHead
	d> d>

	romFileNew d> 0=if S" fil /rom/prg.testblit failed" >d >d panic then
	prg_testblit_start prg_testblit_len 2 d@ >d romFileSetContents
	objEntNew d> 0=if S" ent /rom/prg.testblit failed" >d >d panic then
	S" prg.testblit" >d >d 2 d@ >d objEntSetName d> 0=if S" nam /rom/prg.testblit failed" >d >d panic then
	1 d@ >d 1 d@ >d objEntSetObject
	0 d@ >d 4 d@ >d objDirAddHead
	d> d>

	romFileNew d> 0=if S" fil /rom/prg.lbutest failed" >d >d panic then
	prg_lbutest_start prg_lbutest_len 2 d@ >d romFileSetContents
	objEntNew d> 0=if S" ent /rom/prg.lbutest failed" >d >d panic then
	S" prg.lbutest" >d >d 2 d@ >d objEntSetName d> 0=if S" nam /rom/prg.lbutest failed" >d >d panic then
	1 d@ >d 1 d@ >d objEntSetObject
	0 d@ >d 4 d@ >d objDirAddHead
	d> d>

	romFileNew d> 0=if S" fil /rom/img.kestrel failed" >d >d panic then
	img_kestrel_start img_kestrel_len 2 d@ >d romFileSetContents
	objEntNew d> 0=if S" ent /rom/img.kestrel failed" >d >d panic then
	S" img.kestrel" >d >d 2 d@ >d objEntSetName d> 0=if S" nam /rom/img.kestrel failed" >d >d panic then
	1 d@ >d 1 d@ >d objEntSetObject
	0 d@ >d 4 d@ >d objDirAddHead
	d> d>

	romFileNew d> 0=if S" fil /rom/prg.show failed" >d >d panic then
	prg_show_start prg_show_len 2 d@ >d romFileSetContents
	objEntNew d> 0=if S" ent /rom/prg.show failed" >d >d panic then
	S" prg.show" >d >d 2 d@ >d objEntSetName d> 0=if S" nam /rom/prg.show failed" >d >d panic then
	1 d@ >d 1 d@ >d objEntSetObject
	0 d@ >d 4 d@ >d objDirAddHead
	d> d>

	( root[dir ent] )

	d> d> ;


jump-table: ctvt
jump-entries: callTestProc banner ;

: callTestProc	S" call:" >d >d type cr S" ok" >d >d type cr ;
: callTest	ctvt call  ctvt d> d# 4 + >d call ;

: selfTest	memtest callTest strTest objEntTest objDirTest fsTest libTest ;

: lib0		liblist liblist ! ;

: _		cr banner mem0 selfTest fs0 lib0 romshell bye ;

