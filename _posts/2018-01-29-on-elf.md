---
layout: post
title:  "On ELF"
date:   2018-01-29 21:00:00
---

## Abstract

The Executable and Linkable Format, ELF, is too complex.
Considerable effort is invested to specify the file structure,
yet little effort is invested in specifying normative procedures when working with the file format.
Regrettably,
there currently is no solution to this problem; the standard has spread like mold on bread,
and has permeated every facet of software development on non-Windows platforms.
At best,
you can find tools
which complies with the standard
and which implements the semantics closest to your requirements;
at worst,
you can migrate away from using ELF all-together, but this incurs real development costs.

## ELF On a Shelf

I bet, when ELF first came to be known,
people must have thought the world of it.
Here was a file format which promised to unify loader and linker formats alike,
providing a compatible container for both executables and shared libraries alike,
and which provided this service on a number of different operating systems.

However, while the glossy ads were convincing to what seems like everyone else except me,
actually getting *my* feet wet with this file format proved utterly corrosive.

I found that
the tooling surrounding the standard
must have started relatively simple,
but has since evolved into
a complex and incomprehensible quagmire
of standards and tribal knowledge since then.
This inexorably lead to the platform-specific dependencies and special cases
we see today.
[As it happens, these have real-world costs.](https://duckduckgo.com/?q=exploit+ld.so&t=ffnt&ia=web)
<sup>[1](#realWorldCosts)</sup>

## ELF, The Standard

ELF was originally [introduced](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format)
with AT&T Unix System V Release 4.
On the page linked previously,
an introductory paragraph reads:

    By design, ELF is flexible, extensible, and cross-platform, not bound to
    any given central processing unit (CPU) or instruction set architecture.
    This has allowed it to be adopted by many different operating systems on
    many different hardware platforms.

While I concede that ELF is flexible,
I will argue later on that this is hardly unique to ELF.
Is it extensible?
Yes, but I'll show how doing so is awkward.
There are other formats which are much more extensible.
Is it cross-platform?
This depends on how you define the term.
While the structure of the files are definitely cross-platform,
interpretation of the file's contents most certainly is not.
This can be seen by the wide variety of ABI standards
which the interested reader can find
for various processor architectures,
all of which fills in the gaps
that are missing from the generic ELF standards.
But, here again,
I will argue this is hardly unique to ELF.
Indeed, one of earliest cross-platform executable formats was
the infamous **a.out** format.
I'll show an example of this below as well.

If you're like me,
you probably haven't worked at AT&T Bell Labs when ELF was first invented.
This means you'll need to rely on Google to find your specifications.
So, I'll happily admit here and now that my sources may not necessarily be the most authoritative.

That said, when I look for the ELF Specification,
I'm lead to a document that consists of [60 pages.](http://www.skyfree.org/linux/references/ELF_Format.pdf)
This is fairly heavyweight, if you ask me;
but, let's give it the benefit of the doubt.
Remember, this format aims to fulfill three distinctly different goals:

* Executable format,
* Shared Library format, and,
* Object file format.

Lets ignore that specifications for other loader formats that predate it are much smaller;
if we average 20 pages of specification per role,
it seems ELF is a manageable, even if mildly inconvenient, format.

But, wait, it doesn't stop here.

When ELF was invented, 64-bit systems were not popular.
It needs an additional [18 page](https://uclibc.org/docs/elf-64-gen.pdf)
annex to properly cover 64-bit systems.<sup>[2](#hpIntel)</sup>
This annex assumes familiarity with the preceding 60-page document,
so now we're at, rounding up, 80 pages to read.

But, wait!  **There's more!**

After reading a whopping 80 pages,
you'll quickly realize that you *still don't know how to properly load* an ELF file.
What is entailed with *loading* an ELF file?
That depends on which one of the three kinds of binary artifacts it represents.
If all you're loading is raw binary data which requires no relocation at all,
you can just read the file into an arbitrarily placed buffer and you're done.
This is, perhaps,
where the idea that ELF was "simple" comes from.
However, it's a false prophecy.
As soon as relocations are involved,
you're going to be wishing you'd never used ELF in the first place.

See, to learn how to properly load a binary, regardless of the kind,
you now need to read through the complete specifications
that binds the ELF standard to your specific microprocessor.
In the specific case of AMD's x86-64 platform,
that document takes a whopping [108 pages](http://refspecs.linuxfoundation.org/elf/x86_64-abi-0.95.pdf).
That's 108 pages to tell you such things as:

* how a process starts up, with initial CPU register settings,
* how to invoke the so-called "interpreter" during process image creation (which is still incomplete),
* how to apply relocations to various segments after they've been loaded somehow,
* what relocations there even are to work with,
* whether or not you need a PLT or GOT (don't worry about what these are), or some combined monstrosity called a PLTGOT,
* a description of the menagerie of section types that the main specifications never told you about,
* and more!

Long story short,
to get *an inkling of an idea* of how to properly apply ELF to your loading needs,
you need to basically read through 186 pages of documentation.
The sad part is, even after all this documentation,
you still won't know definitively how to actually go about applying this knowledge.
This is where the tribal knowledge comes into play.
Want to build an ELF loader?  Better read the source to `ld.so` first!
Oh my goodness, you can't make sense of it?
Tsk tsk, you don't have any business building a loader;
you're clearly unskilled in the art.

Hogwash.



## Conclusion

t.b.d.

----
<a name="realWorldCosts">1</a>:
I originally wanted to link to a single incident I had in mind.
However, upon realizing just how *many* exploits have happened,
I figured I'd show you what a single search query can yield.
It's dumbfounding.
When faced with this evidence,
one *cannot* deny the complex semantics behind ELF
and its relationship with the surrounding operating system
makes the continued reliance upon it a security liability.

<a name="hpIntel">2</a>:
I didn't notice, or I'd simply forgotten until re-reading recently,
that this standard started out as a platform-specific extension to ELF.
This was originally used
between Hewlett-Packard and Intel
for their respective 64-bit CPUs.
