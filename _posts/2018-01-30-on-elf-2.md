---
layout: post
title:  "On ELF, Part 2"
date:   2018-01-30 21:00:00
---

## Abstract

The Executable and Linkable Format, ELF, is too complex.
I firmly feel it was created without critically thinking about the ramifications it would have on future tool chains.
In this article,
I show how ELF-like features can be safely retrofitted onto executable formats contemporary with ELF's debut.
Hopefully, future executable format authors will reconsider their needs more critically in the future before committing to something as complicated as ELF.

## Basic Principles

Before writing this installment,
I had a realization.
One of the big mistakes from Unix,
besides the X Window System,
was the `ld` linker.
At the time, it must have seemed like a great idea!
Put yourself in the original authors' shoes:
why should the kernel spend so much effort relocating a binary
when that image will just appear at the same place in every process?
So, why not just relocate any linked executable at that point *before* the kernel ever gets a chance to see it?
The kernel can be made much simpler
(just read in an opaque binary blob, then call a specified address),
and as a nice side-effect,
it's faster to load the programs as well,
which was probably noticeable on timesharing systems of that era.

But, as we've seen in the [previous article,]({{site.baseurl}}/kestrel/2018/01/29/on-elf)
this can open a can of worms from the security point of view
as well as constrain new features,
such as the new hotness at about this time, component-oriented programming
(what eventually led to CORBA and DCOM).
It turns out that program relocation at load-time is a *good* thing.<sup>[1](#opposingView)</sup>
The design of ELF, in part,
reflects the realization that mistakes were made in the past,
and AT&T wanted to both move forward with new features while preserving at least some of their initial investment.
(Aside: I, personally, have mixed feelings about this;
but, this article is not about those specific feelings.)

So, *why* is `ld` such a big mistake?
Bluntly, it's a tool which, like ELF, fails to adhere to the Unix philosophy of
doing one thing well.
See, `ld` is responsible for at least two services:

* Linking multiple compiler artifacts into a single artifact for later re-use in the construction of software, and,
* Producing a loadable binary from one or more of these re-usable artifacts.

While these two concepts are clearly *related*,
they are most definitely not *the same thing*.
We see that the
[Plan 9 compiler toolchain](http://doc.cat-v.org/bell_labs/new_c_compilers/new_c_compiler.pdf)
partially remedies this past oversight
by keeping software in a binary representation of an assembly language listing
for as long as possible before the very last step of producing the final binary executable.

Basically, there are two principles involved.

**Principle of Linking.**
A linker's job is to coalesce, merge, and perhaps even sort *sections* of equivalent *type*.
If it helps you, think of it as a merge-sort for related code.
A typical program might have hundreds of sections,
which a linker might reduce to a smaller, perhaps still quite numerous, quantity.
Ultimately, by the time you yield a final executable,
it's been massaged down to a much smaller set
(typically, text, data, and BSS).

**Principle of Loading.**
A loader's job is to unmarshall the concrete program representation in memory from an off-line representation.
This *prepares* a program for execution.
In the case of dynamic linking,
a loader *may* perform some basic relocations,
but *it never merges sections of comparable types.*
It just lays them out in the address space somehow.
This can be seen on any Linux installation by looking at a process' memory map layout
(`sudo cat /proc/$PID/maps`,
which will show each dynamically loaded module's text, data, BSS, and stack segments).
I'm sure BSD and Plan 9 have similarly accessible methods of showing this information.

Where `ld` goes wrong, then,
is that it attempts to both *link* and *load* in one step.
The limitations of this approach do not become visible as long as

* Your runtime environment is isolated via a page-capable MMU, and,
* You have no need whatsoever for dynamic linking.

Violate any of these assumptions, and
`ld`'s approach breaks down hard.
This is why `ld` requires so many horrible-looking arguments when linking code together:
one set of options intends to put a choke-hold on `ld` from building an executable or shared object
when all you want is a relocatable module,
while another set is often to do just the opposite.

I mention this only because
I want this article to focus exclusively on *program loading.*
That is, nothing I write in this article is intended to relate to *linking* at all.
The formats below may or may not make suitable targets for linkers.
In fact, there's a great chance that they won't at all.
Plan 9 accepts this.  There's no reason why the progeny of Unix can't either.

So, with the full understanding that we're talking *exclusively* about *loading* programs,
let us now tear ELF a new hole in its address space by illustrating viable alternatives to it.

## ELF versus GEMDOS PRG Format

In the previous article,
I had stated that the `a.out` format was
one of the earliest and most portable of executable formats around.
To illustrate this point,
let's compare [Unix's original `a.out` format](https://www.bell-labs.com/usr/dmr/www/man51.pdf) to
an OS where you might not have expected it to show up:
[Atari TOS and GEMDOS](http://toshyp.atari.org/en/005005.html),
the two components that make up the Atari ST/TT's operating system.

**PDP-11 Unix**

    struct aout_unix {
        short   a_magic;    // 0x0085
        short   a_textsz;   // Size of .text segment
        short   a_symsz;    // Size of symbol tables
        short   a_relocsz;  // Size of fixups
        short   a_datasz;   // Size of .data segment
        short   a_padding;
    };

**Atari TOS**

    typedef struct
    {
       WORD  ph_branch;        /* Branch to start of the program  */
                               /* (must be 0x601a!)               */

       LONG  ph_tlen;          /* Length of the TEXT segment      */
       LONG  ph_dlen;          /* Length of the DATA segment      */
       LONG  ph_blen;          /* Length of the BSS segment       */
       LONG  ph_slen;          /* Length of the symbol table      */
       LONG  ph_res1;          /* Reserved, should be 0;          */
                               /* Required by PureC               */
       LONG  ph_prgflags;      /* Program flags                   */
       WORD  ph_absflag;       /* 0 = Relocation info present     */
    } PH;

Some observations:

* The respective fields appear in different places depending on which header is used.  But, that's OK; ELF 32-bit and 64-bit structures also have fields which move about to support different processor alignment restrictions.
* TOS supports an explicit `.bss` segment, while the original Unix loader did not.  BSS was just a pre-zeroed bunch of bytes tacked onto the end of `.data`, and accounted for in `a_datasz`.
* Interestingly, both the PDP-11 and the 68000 formats supported fixups to resolve code and data references.  This suggests there was a time when Unix did not run with a page-based MMU.

After the file header,
you'll find the actual executable artifacts:


    +-------------------------------+
    | PH header                     |
    +-------------------------------+
    | TEXT segment                  |
    +-------------------------------+
    | DATA segment                  |
    +-------------------------------+
    | Symbol table                  |
    +-------------------------------+
    | Relocation table              |
    +-------------------------------+

That's it:
there are no tables containing pointers to segments,
there are no complex graphs to traverse to get at some piece of information,
there exists no reason to invest more than a handful of printed pages to describe the entire structure.
Despite this minimalism,
the `a.out` format is surprisingly versatile.
It supported TOS applications in a single address space,
it supported MultiTOS applications in a single address space,
and it later supported MultiTOS applications in *separate* address spaces as well.
Clearly, we see that `a.out` is quite adept
at handling both DOS-like and Unix-like environments with equal facility.

Note that some details differ between the two `a.out` headers.
That's perfectly OK.
Exact layout doesn't matter,
what matters are the concepts supported.
It gives the loader just enough information to allocate a chunk of memory for code,
a chunk of memory for data and BSS,
to locate the relevant data in the files and load them into the allocated memory,
and then apply fixups to resolve broken references.
The `a.out` binaries were self-contained and self-consistent otherwise:
it was not possible to legally create an `a.out` file
which referred to an undefined symbol.
Intra-segment relocations
(for instance, where a symbol in module A's `.text` segment
refers to a symbol in the `.text` segment in module B)
are resolved by the linker *prior* to emitting the final `a.out`,
often relying upon PC-relative or register-relative addressing.
Absolute references (e.g., with JSR or JMP instructions,
or when storage in `.data` was referenced from a location in `.text`)
were resolved using the bundled fixups.
The reason for this is that there was little to no guarantee that `.data` and `.text`
would remain adjacent in the computer's address space,
particularly for single-address space environments.

In my previous article,
I'd stated that `a.out` was intended to be loaded/mapped blindly as an opaque blob.
This is especially evident in the original Unix header,
as the "magic" field, used to identify executables from other file types,
is *literally* a PDP-11 machine language instruction that *jumps over the header.*
The Atari TOS program header continues this tradition.

### Extending to Support Dynamic Linking

OK, so now that we've seen how trivial `a.out` is,
how do we extend it to support dynamic linking?
Pretend, for a moment, that you were in charge of adding
dynamic linking to MultiTOS for its next release.
How would you retrofit this loader format to do so?
Here is how *I* would handle the task.

### Required Extensions

The first task would be to identify what additional support
is required to handle the job.

First and foremost, a statically linked binary
is expected to be self-contained.
Dynamic linking throws that assumption out the door;
therefore, we need a way for a module to identify its dependencies.
So, we need to introduce a segment that lists library dependencies.
Let's not concern ourselves with precise layout at this point;
we only need to know that it consumes space in the file, and thus,
has a size field associated with it.

Second, we observe that dynamically linked modules
may require symbols defined in the executable.
It turns out `a.out` has us covered here,
as both PDP-11 and TOS versions of the file support a symbol table explicitly.
Convenient!
So out-bound definitions are taken care of;
however, *in-bound* relocations are not.
There are two ways to handle this:
first, we can extend the existing symbol table definition
to support both symbol definitions *and* symbol references,
or we can introduce a separate symbol table segment just for in-bound references.
Just to make things harder and for the sake of illustration,
we'll assume the latter.
In the real-world, I'd probably shoot for the former.

To support in-bound symbol relocations,
we will also need to extend our relocation records.
Atari TOS uses a very simplistic model:
every N bytes, add the base address of the appropriate segment to the 32-bit word at that current location.
Again, the assumption is that references are self-consistent/self-contained,
so this is fine if all you're doing is relocating a microcosm of code.
For dynamic linking, however,
we need to know not only where to perform the relocations,
but also against what symbol.
For this reason,
I would replace individual bytes in the relocation segment
with 32-bit words, with a layout along these lines:

     3 2 2         0
     1 4 3         0
    +---+-----------+
    | D |     d     |  Type 1
    +---+-----------+

    +---+-----------+
    | D |     S     |  Type 2
    +---+-----------+

This makes for a larger executable file, but is also substantially more flexible.
The rules are as follows:

* If D=255, then we have a type-1 relocation record, which basically says, "There's no relocation at this point; however, the next relocation record is going apply *d* bytes from here in the file."
* If D<255, then we have a type-2 relocation record.  This says to the loader, "Fix up the current 32-bit word with the value of the *S*-th symbol in the symbol table, then advance *D* (capital!) bytes in the program image."

In both cases,
we know if we're making a code or data segment reference
based both on the value of the referenced symbol, and
on the relative offset we're patching in the `a.out` file.

So far as I'm aware, this is all that is required to make the format support dynamic linking.
Now let's lay this stuff out into something that makes the task of loading it *easy*.

### Refined Header Structures

Since the initial `ph_branch` is a 68000 `BRA` instruction that
skips over the length of the program header,
it follows that if we append our extra fields onto the program header,
then we must adjust the branch offset as well.
This implies we create a new magic cookie for `ph_branch`
which the loader can use to determine if the binary is dynamically linked or not.

Just in case some other file type uses this same magic value,
we're going to use an unused `ph_prgflags` bit to identify a dynamically linked artifact.
Let's call it `PRGF_DYNAMIC`.

If `ph_branch` is correct yet `PRGF_DYNAMIC` is not set,
then we either have a corrupt program header,
or the file is not actually a dynamically linked executable.
Thus, we reject the file.

The following fields can appear immediately after the `ABSFLAG` field:

    typedef struct
    {
       WORD  ph_branch;         // Magic: 0x6022
       LONG  ph_tlen;           // as before.
       LONG  ph_dlen;           // as before.
       LONG  ph_blen;           // as before.
       LONG  ph_slen;           // as before.
       LONG  ph_res1;           // as before.
       LONG  ph_prgflags;       // Make sure PRGF_DYNAMIC is set!
       WORD  ph_absflag;        // as before.
       LONG  phx_deplen;        // Length of dependencies.
       LONG  phx_implen;        // Length of imported symbols.
    } PHDYN;

Observe that loading the module's code and data segments
is meaningless
if we can determine ahead of time that
we cannot satisfy this module's dependencies.
For this reason, we need only insert our list of dependencies
and symbol imports, in that order, *ahead* of the code segment.
In this way, you can still compute the offsets of everything
without having to provide explicit pointers.
This keeps the size of the header down.
We also take care to order the segments we'll need in the order we'll use them.

* We first find exported symbols, since it's possible that dependencies may require a symbol defined by the executable itself.  So, the loader must process locally defined symbols first.
* Then, we transitively load dependencies using a depth-first traversal of the dependency tree.
* Once all dependencies have been loaded, *then* we can resolve imported symbols for *this* module.  If any are left unresolved, then we abort further loading with an undefined symbol error.
* At this point, we can finally handle loading our TEXT, DATA, and BSS segments, along with any relocations they may require.

By doing things in this order,
we minimize unnecessary seeking through the file.

    +-------------------------------+
    | PHDYN header                  |
    +-------------------------------+
    | exported symbols (new)        |
    | (replaces old symbol table)   |
    +-------------------------------+
    | dependencies (new)            |
    +-------------------------------+
    | imported symbols (new)        |
    +-------------------------------+
    | TEXT segment                  |
    +-------------------------------+
    | DATA segment                  |
    +-------------------------------+
    | Relocation table (new)        |
    | (replaces old reloc table)    |
    +-------------------------------+

### Normative Procedures

Here, we get to the basic algorithm of loading and relocating a dynamic executable using this format.

You'll notice a reference to a *global context*.
This is some arbitrary data structure
that serves as a global record-keeping device
keeping track of resources allocated and/or files opened.
In Unix, this would be the process itself.
For something like TOS, this structure would need to exist separately.
Either way, it's required if we want to properly track resources
in the event we return with an error.
Otherwise, resources will be allocated but unable to be freed,
since we wouldn't have a long-standing reference to them.
The context also serves as a rendezvous point for symbols,
where they're defined,
and what value they equate to.

First, we start out at the top level:
when loading a PRG, we dispatch to the appropriate loader based on `ph_branch` values.

    PROCEDURE LoadPRG(filename)
    BEGIN
        Read first two bytes of file.
        IF ph_branch == 0x601A THEN
            Load statically linked PRG file.
        ELSIF ph_branch == 0x6022 THEN
            Create global loader context.
            LoadDynamicPRG(filename, context)
        ELSE
            Return with an unrecognized file type error.
        END
    END

The legacy loader, as defined in GEMDOS, can be used to load the statically-linked executable,
so I won't repeat its pseudo-code here.
Instead, let's focus on the dynamic loader.

    PROCEDURE LoadDynamicPRG(filename, context)
    BEGIN
        Read rest of the PHDYN header.
        IF PRGF_DYNAMIC not in ph_prgflags THEN
            Return with an unrecognized file type error.
        END

        // Process locally defined symbols so that any dependencies
        // can find them and use them.

        FOR ALL s IN locally defined symbols DO
            Create symbol descriptor for s in the context.
        END

        // Transitively load all dependencies.

        FOR ALL d IN dependencies DO
            Resolve dependency d to library filename.
            LoadDynamicPRG(Filename(dependency), context)
            IF not successful THEN
                Free all allocated or opened resources so far.
                Return with an error code.
            END
        END

        // We've just loaded all of our dependencies, and they are
        // happy with the symbols we've exported.  Let's now resolve
        // our own symbol imports.  This can potentially take some
        // amount of time; O(n^2) algorithm.

        FOR ALL s IN imported symbols DO
            FOR all dependencies we loaded above DO
                IF dependency contains symbol THEN
                    Create descriptor for s in the context.
                    Exit this loop and continue outer loop.
                END
            END
            // No dependency claims to define the symbol.
            // Abort with an undefined symbol error.
            Free all allocated or opened resources so far.
            Return with an error code.
        END

        // We transitively loaded our dependencies.  We've resolved
        // all of our symbols.  Now it's time to load our text and data
        // segments and apply relocations to them.

        AllocateTextSegment()
        ReadTextSegment()
        AllocateDataSegment()
        ReadDataSegment()
        AllocateBssSegment()
        ZeroBssSegment()

        offset = 0
        segment = TextSegment
        IF length(relocations) > 0 THEN
            FOR ALL r IN relocations DO
                IF
                    offset >= length(TextSegment) AND
                    segment = TextSegment
                THEN
                    segment = DataSegment
                    offset = offset - length(TextSegment)
                END
                IF
                    offset >= length(DataSegment) AND
                    segment = DataSegment
                THEN
                    segment = BssSegment
                    offset = offset - length(DataSegment)
                END
                IF IsType2(r) THEN
                    x = GetWord(segment+offset)
                    v = SymbolValue(SymbolDescriptorFor(r))
                    PutWord(segment+offset, x+v)
                END
                offset = offset + displacement(r)
            END
        END
    END

This pseudo-code is more or less representative of the actions that must be taken
for someone to extend GEM's PRG format to include dynamic linking abilities.
Actual code is straight-forward,
the code follows the layout of the data as found in the executable file,
and should be easily maintained as future requirements dictate.

This pseudo-code does not handle the case where a shared library is already resident in memory.
However, with a small change to the calling convention of the `LoadDynamicPRG` procedure,
it should be possible to short-circuit the loading process for resident libraries.

### Handling Other Processor Architectures

The pseudo-code above assumes the same 680x0 processor family that drives the Atari ST/TT line.
As written, it won't scale to newer architectures.
Many RISC processors requires multiple kinds of relocations to resolve references,
since instructions rarely can pack a full word's worth of bits in an instruction.
For example, a RISC-V processor can only address +/- 2KiB from some base address.
For a 32-bit address, then, you need to break the reference up across two instructions:
a LUI instruction to load the upper 20 bits of the address,
and an addition to contribute the lower 12 bits.
Worse still, the addition is sign-extended, which must be accounted for in the upper portion of the address.

A 64-bit RISC-V implementation can't even use this approach,
for there is no way to embed the upper 32-bits of an address directly into the instruction stream.
You end up loading addresses indirectly from a code or data word of memory,
and *that* is what receives the relocation.
Alternatively, if the value has lots of binary 0s in it,
you can load a portion of the address in the low-order bits and then shift up appropriately.
As you can see, resolving a 64-bit address on RISC-V can potentially be messy.

Assuming a 64-bit RISC-V target,
the loader will need to understand how to perform a minimum of four different kinds of relocations:

* Absolute 32-bit relocation
* Absolute 64-bit relocation
* Upper 20-bits for LUI
* Lower 12-bits for ADDI

This can be encoded easily enough in the relocation segment of the file.
You just need to make the relocation record format known to the loader somehow,
either implicitly through the `ph_branch` magic cookie,
or via additional header fields.

### Handling Initializations and Finalizations

Some languages,
like Modula-2 and C++,
often require objects to be pre-initialized via "constructors" before the main program begins.
In the case of Modula-2 and Oberon,
the "constructor" is the global body of a module definition.
In C++, D, Sather, et. al., these are provided through more explicit programming constructs on classes.
Either way, they *must* be invoked for the main program to run correctly.
After all, the executable might be written in plain-vanilla C,
while the library you're depending upon could very well be written in C++!

In a statically linked executable,
this is not a problem, since the linker is given libraries which are capable of handling this issue.
It has compile-time (at best) or link-time (at worst) knowledge of which routines to call and when.
Thus, it can provide supporting code in the `.text` segment, and the day is saved.

For dynamically linked executables, however, it's not as simple.
Since the linker and loader *both* have no idea what languages modules are written in,
the loader must support a means of calling constructors independently of the main program's entry point.
The ELF `.init`, `.fini`, and related sections all exist
to support languages
which require global constructors to be called before invoking the main program.

We map this to the `a.out` file by requiring initializers and finalizers to exist in the `.text` segment.
Further, instead of providing a single routine to call, we express requirements as a *vector* of routines to call.
These can be handled by extending the `a.out` header once more with the following fields:

    LONG    phx_ivecbase;   // Offset to base of initializer vector
    LONG    phx_ivecsize;   // Number of initializers to call
    LONG    phx_fvecbase;   // Offset to base of finalizer vector
    LONG    phx_fvecsize;   // Number of finalizers to call

From the loader's point of view,
there's nothing special about these vectors.
The linker must provide zero or more such vector entries for each module it helps produce.
The loader, then, must take on the responsibility of invoking them as it loads module dependencies.

## ELF versus AmigaDOS Hunk Format
## Conclusion

I've shown how one can build a dynamic loader for the `a.out` format.
It involves adding a few missing fields and pseudo-segments to the file,
but it is not impossible, and it's patently much simpler than ELF's current file structure.

----
<a name="opposingView">1</a>:
For a quite compelling argument against this point of view,
please read this collection of quotes against
[dynamic linking in general,](http://harmful.cat-v.org/software/dynamic-linking/)
and a uniquely ELF-related concept of
[*versioned symbols*.](http://harmful.cat-v.org/software/dynamic-linking/versioned-symbols)

