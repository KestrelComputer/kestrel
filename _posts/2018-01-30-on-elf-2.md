---
layout: post
title:  "On ELF, Part 2"
date:   2018-01-30 21:00:00
---

## Abstract

The Executable and Linkable Format, ELF, is too complex.
I firmly feel it was created without critically thinking about the ramifications it would have on future tool chains.
In this article, I show how ELF-like features can be safely retrofitted onto contemporary executable formats.
Hopefully, future executable format authors will reconsider their needs more critically in the future before committing to something as complicated as ELF.

## Basic Principles

Before writing this installment,
I had a realization.
One of the big mistakes from Unix,
besides the X Window System,
was the `ld` linker.
At the time, it must have seemed like a great idea!
Put yourself in the original authors' shoes:
why should the kernel spend so much effort relocating a binary
when that image will just appear at the same place in every process?
So, why not just relocate any linked executable at that point *before* the kernel ever gets a chance to see it?
The kernel can be made much simpler
(just read in an opaque binary blob, then call a specified address),
and as a nice side-effect,
it's faster to run loaded programs as well.

But, as we've seen in the previous article,
this can open a can of worms from the security point of view
as well as constrain new features,
such as the new hotness at about this time, component-oriented programming
(what eventually led to CORBA and DCOM).
It turns out that program relocation at load-time is a *good* thing.<sup>[1](#opposingView)</sup>
The design of ELF, in part,
reflects the realization that mistakes were made in the past,
and AT&T wanted to both move forward with new features while preserving at least some of their initial investment.
(Aside: I, personally, have mixed feelings about this;
but, this article is not about those specific feelings.)

So, *why* is `ld` such a big mistake?
Bluntly, it's a tool which, like ELF, fails to adhere to the Unix philosophy of
doing one thing well.
See, `ld` is responsible for at least two services:

* Linking multiple compiler artifacts into a single artifact for later re-use in the construction of software, and,
* Producing a loadable binary from one or more of these re-usable artifacts.

While these two concepts are clearly *related*,
they are most definitely not *the same thing*.
We see that the
[Plan 9 compiler toolchain](http://doc.cat-v.org/bell_labs/new_c_compilers/new_c_compiler.pdf)
partially remedies this past oversight
by keeping software in a binary representation of an assembly language listing
for as long as possible before the very last step of producing the final binary executable.

Basically, there are two principles involved.

**Principle of Linking.**
A linker's job is to coalesce, merge, and perhaps even sort *sections* of equivalent *type*.
If it helps you, think of it as a merge-sort for related code.
A typical program might have hundreds of sections,
which a linker might reduce to a smaller, perhaps still quite numerous, quantity.
Ultimately, by the time you yield a final executable,
it's been massaged down to a much smaller set
(typically, text, data, and BSS).

**Principle of Loading.**
A loader's job is to unmarshall the concrete program representation in memory from an off-line representation.
This *prepares* a program for execution.
In the case of dynamic linking,
a loader *may* perform some basic relocations,
but *it never merges sections of comparable types.*
It just lays them out in the address space somehow.
This can be seen on any Linux installation by looking at a process' memory map layout
(`sudo cat /proc/$PID/maps`,
which will show each dynamically loaded module's text, data, BSS, and stack segments).
I'm sure BSD and Plan 9 have similarly accessible methods of showing this information.

Where `ld` goes wrong, then,
is that it attempts to both *link* and *load* in one step.
The limitations of this approach do not become visible as long as

* Your runtime environment is isolated via a page-capable MMU, and,
* You have no need whatsoever for dynamic linking.

Violate any of these assumptions, and
`ld`'s approach breaks down hard.
This is why `ld` requires so many horrible-looking arguments when linking code together:
one set of options intends to put a choke-hold on `ld` from building an executable or shared object
when all you want is a relocatable module,
while another set is often to do just the opposite.

I mention this only because
I want this article to focus exclusively on *program loading.*
That is, nothing I write in this article is intended to relate to *linking* at all.
The formats below may or may not make suitable targets for linkers.
In fact, there's a great chance that they won't at all.
Plan 9 accepts this.  There's no reason why the progeny of Unix can't either.

So, with the full understanding that we're talking *exclusively* about *loading* programs,
let us now tear ELF a new hole in its address space by illustrating viable alternatives to it.

## ELF versus GEMDOS PRG Format

In the previous article,
I had stated that the `a.out` format was
one of the earliest and most portable of executable formats around.
To illustrate this point,
let's compare [Unix's original `a.out` format](https://www.bell-labs.com/usr/dmr/www/man51.pdf) to
an OS where you might not have expected it to show up:
[Atari TOS and GEMDOS](http://toshyp.atari.org/en/005005.html),
the two components that make up the Atari ST/TT's operating system.

**PDP-11 Unix**

    struct aout_unix {
        short   a_magic;    // 0x0085
        short   a_textsz;   // Size of .text segment
        short   a_symsz;    // Size of symbol tables
        short   a_relocsz;  // Size of fixups
        short   a_datasz;   // Size of .data segment
        short   a_padding;
    };

**Atari TOS**

    typedef struct
    {
       WORD  ph_branch;        /* Branch to start of the program  */
                               /* (must be 0x601a!)               */

       LONG  ph_tlen;          /* Length of the TEXT segment      */
       LONG  ph_dlen;          /* Length of the DATA segment      */
       LONG  ph_blen;          /* Length of the BSS segment       */
       LONG  ph_slen;          /* Length of the symbol table      */
       LONG  ph_res1;          /* Reserved, should be 0;          */
                               /* Required by PureC               */
       LONG  ph_prgflags;      /* Program flags                   */
       WORD  ph_absflag;       /* 0 = Relocation info present     */
    } PH;

Some observations:

* The respective fields appear in different places depending on which header is used.  But, that's OK; ELF 32-bit and 64-bit structures also have fields which move about to support different processor alignment restrictions.
* TOS supports an explicit `.bss` segment, while the original Unix loader did not.  I'm guessing BSS was just a pre-zeroed bunch of bytes tacked onto the end of `.data`, and accounted for in `a_datasz`.
* Interestingly, both the PDP-11 and the 68000 formats supported fixups to resolve code and data references.  This suggests there was a time when Unix did not run with a page-based MMU.

After the file header,
you'll find the actual executable artifacts:


    +-------------------------------+
    | PH header                     |
    +-------------------------------+
    | TEXT segment                  |
    +-------------------------------+
    | DATA segment                  |
    +-------------------------------+
    | Symbol table                  |
    +-------------------------------+
    | Relocation table              |
    +-------------------------------+

That's it.  The `a.out` format is surprisingly versatile considering its simplicity.
It supported TOS applications in a single address space,
it supported MultiTOS applications in a single address space,
and it later supported MultiTOS applications in *separate* address spaces as well.
Clearly, we see that `a.out` is quite adept
at handling both DOS-like and Unix-like environments with equal facility.

Note that some details differ between the two `a.out` headers.
That's perfectly OK.
Exact layout doesn't matter,
what matters are the concepts supported.
It gives the loader just enough information to allocate a chunk of memory for code,
a chunk of memory for data and BSS,
to locate the relevant data in the files and load them into the allocated memory,
and then apply fixups to resolve broken references.
The `a.out` binaries were self-contained and self-consistent otherwise:
it was not possible to legally create an `a.out` file
which referred to an undefined symbol.
Intra-segment
(for instance, where a symbol in module A's `.text` segment
refers to a symbol in the `.text` segment in module B)
relocations are resolved by the linker prior to emitting the final `a.out`,
so that (in most cases) they used PC-relative or register-relative addressing.
Absolute references (e.g., with JSR or JMP instructions,
or when storage in `.data` was referenced from a location in `.text`)
were resolved using the bundled fixups.
The reason for this is that there was little to no guarantee that `.data` and `.text`
would remain adjacent in the computer's address space,
particularly for single-address space environments.

In the previous article,
I'd stated that `a.out` was intended to be loaded/mapped blindly as an opaque blob.
This is especially evident in the original Unix header,
as the "magic" field, used to identify executables from other file types,
is *literally* a PDP-11 machine language instruction that *jumps over the header.*

### Extending to Support Dynamic Linking

OK, so now that we've seen how trivial `a.out` is,
how do we extend it to support dynamic linking?
Pretend, for a moment, that you were in charge of adding
dynamic linking to MultiTOS for its next release.
How would you retrofit this loader format to do so?
Here is how *I* would handle the task.

### Required Extensions

The first task would be to identify what additional support
is required to handle the job.

First and foremost, a statically linked binary
is expected to be self-contained.
Dynamic linking throws that assumption out the door;
therefore, we need a way for a module to identify its dependencies.
So, we need to introduce a segment that lists library dependencies.

Second, we observe that dynamically linked modules
may require symbols defined in the executable.
It turns out `a.out` has us covered here,
as both PDP-11 and TOS versions of the file support a symbol table explicitly.
Convenient!
So out-bound definitions are taken care of;
however, *in-bound* relocations are not.
There are two ways to handle this:
first, we can extend the existing symbol table definition
to support both symbol definitions *and* symbol references,
or we can introduce a separate symbol table segment just for in-bound references.
Just to make things harder and for the sake of illustration,
we'll assume the latter.
In the real-world, I'd probably shoot for the former.

To support in-bound symbol relocations,
we will also need to extend our relocation records.
Atari TOS uses a very simplistic model:
every N bytes, add the base address of the appropriate segment to the 32-bit word at that current location.
Again, the assumption is that references are self-consistent/self-contained,
so this is fine if all you're doing is relocating a microcosm of code.
For dynamic linking, however,
we need to know not only where to perform the relocations,
but also against what symbol.
For this reason,
I would replace individual bytes in the relocation segment
with 32-bit words, with a layout along these lines:

    +---+-----------+
    | D |     d     |  Type 1
    +---+-----------+

    +---+-----------+
    | D |     S     |  Type 2
    +---+-----------+

The rules are as follows:

* If D=255, then we have a type-1 relocation record, which basically says, "The next relocation record is going apply at offset d in the file."  This limits your binary size to 16MB as defined (24-bit d field), maybe 64MB if you can guarantee that all 32-bit offsets are 32-bit aligned.  However, I doubt this would ever be a problem.
* If D<255, then we have a type-2 relocation record.  This says to the loader, "Fix up the current 32-bit word with the value of the S-th symbol in the symbol table, then advance D bytes in the program image."

In both cases,
we know if we're making a code or data segment reference based on the relative offset we're patching in the `a.out` file.

So far as I'm aware, this is all that is required to make the format support dynamic linking.

### Refined Header Structures

Now that we know what we need from the data structure,
we can define our backward-compatible extensions to the `a.out` structure.

Since the initial `ph_branch` is a 68000 `BRA` instruction that
skips over the length of the program header,
it follows that if we append our extra fields onto the program header,
then we must adjust the branch offset as well.
This implies we create a new magic cookie for `ph_branch`
which the loader can use to determine if the binary is dynamically linked or not.

Just in case some other file type uses this same magic value,
we're going to use an unused `ph_prgflags` bit to identify a dynamically linked artifact.
Let's call it `PRGF_DYNAMIC`.

If `ph_branch` is correct yet `PRGF_DYNAMIC` is not set,
then we either have a corrupt program header,
or the file is not actually a dynamically linked executable.
Thus, we reject the file.

The following fields can appear immediately after the `ABSFLAG` field:

    typedef struct
    {
       WORD  ph_branch;         // Magic: 0x6022
       LONG  ph_tlen;
       LONG  ph_dlen;
       LONG  ph_blen;
       LONG  ph_slen;
       LONG  ph_res1;
       LONG  ph_prgflags;       // Make sure PRGF_DYNAMIC is set!
       WORD  ph_absflag;
       LONG  phx_deplen;        // Length of dependencies.
       LONG  phx_implen;        // Length of imported symbols.
    } PHDYN;

**Note:**
Observe that loading the module's code and data segments
is meaningless
if we can determine ahead of time that
we cannot satisfy this module's dependencies.
For this reason, we need only insert our list of dependencies
and symbol imports, in that order, *ahead* of the code segment.
In this way, you can still compute the offsets of everything
without having to provide explicit pointers to everything.
We also take care to order the segments we'll need in the order we'll use them.

* We first find exported symbols, since it's possible that dependencies may require a symbol defined by the executable itself.  So, the loader must process locally defined symbols first.
* Then, we transitively load dependencies using a depth-first traversal of the dependency tree.
* Once all dependencies have been loaded, *then* we can resolve imported symbols for this module.  If any are left unresolved, then we abort further loading with an undefined symbol error.
* At this point, we can finally handle loading our TEXT, DATA, and BSS segments, along with any relocations they may require.

By doing things in this order,
we minimize unnecessary seeking through the file.

    +-------------------------------+
    | PHDYN header                  |
    +-------------------------------+
    | exported symbols (new)        |
    | (replaces old symbol table)   |
    +-------------------------------+
    | dependencies (new)            |
    +-------------------------------+
    | imported symbols (new)        |
    +-------------------------------+
    | TEXT segment                  |
    +-------------------------------+
    | DATA segment                  |
    +-------------------------------+
    | Relocation table (new)        |
    | (replaces old reloc table)    |
    +-------------------------------+

### Normative Procedures

Here, we get to the basic algorithm of loading and relocating a dynamic executable using this format.

    PROCEDURE LoadPRG(filename)
    BEGIN
        Read first two bytes of file.
        Create global loader context.
        IF ph_branch == 0x601A THEN
            Load statically linked PRG file.
        ELSIF ph_branch == 0x6022 THEN
            LoadDynamicPRG(filename, context)
        ELSE
            Return with an unrecognized file type error.
        END
    END

    PROCEDURE LoadDynamicPRG(filename, context)
    BEGIN
        Read PHDYN header.
        IF PRGF_DYNAMIC not in ph_prgflags THEN
            Return with an unrecognized file type error.
        END

        // Process locally defined symbols so that any dependencies
        // can find them and use them.

        FOR ALL s IN locally defined symbols DO
            Create symbol descriptor for s.
        END

        // Transitively load all dependencies.

        FOR ALL d IN dependencies DO
            Resolve dependency d to library filename.
            LoadDynamicPRG(Filename(dependency), context)
            IF not successful THEN
                Free all allocated or opened resources so far.
                Return with an error code.
            END
        END

        // By the time we're done with this step, we'll know about
        // all exported symbols, and all symbols we imported and from
        // which dependency they come from.

        FOR ALL s IN imported symbols DO
            FOR all dependencies we loaded above DO
                IF dependency contains symbol THEN
                    Create descriptor for s.
                    Exit this loop and continue outer loop.
                END
            END
            // No dependency claims to define the symbol.
            // Abort with an undefined symbol error.
            Free all allocated or opened resources so far.
            Return with an error code.
        END

        // We transitively loaded our dependencies.  We've resolved
        // all of our symbols.  Now it's time to load our text and data
        // segments and apply relocations to them.

        AllocateTextSegment()
        ReadTextSegment()
        AllocateDataSegment()
        ReadDataSegment()
        AllocateBssSegment()
        ZeroBssSegment()

        offset = 0
        segment = TextSegment
        IF length(relocations) > 0 THEN
            FOR ALL r IN relocations DO
                IF
                    offset >= length(TextSegment) AND
                    segment = TextSegment
                THEN
                    segment = DataSegment
                    offset = offset - length(TextSegment)
                END
                IF
                    offset >= length(DataSegment) AND
                    segment = DataSegment
                THEN
                    segment = BssSegment
                    offset = offset - length(DataSegment)
                END
                IF IsType2(r) THEN
                    x = GetWord(segment+offset)
                    v = SymbolValue(SymbolDescriptorFor(r))
                    PutWord(segment+offset, x+v)
                END
                offset = offset + displacement(r)
            END
        END
    END

This pseudo-code is more or less representative of the actions that must be taken
for someone to extend GEM's PRG format to include dynamic linking abilities.
Actual code is straight-forward,
the code follows the layout of the data as found in the executable file,
and should be easily maintained as future requirements dictate.

The pseudo-code above assumes the same 680x0 processor family that drives the Atari ST/TT line.
As written, it won't scale to newer architectures.
Many RISC processors requires multiple kinds of relocations to resolve references,
since instructions rarely can pack a full word's worth of bits in an instruction.
For example, a RISC-V processor can only address +/- 2KiB from some base address.
For a 32-bit address, then, you need to break the reference up across two instructions:
a LUI instruction to load the upper 20 bits of the address,
and an addition to contribute the lower 12 bits.
Worse still, the addition is sign-extended, which must be accounted for in the upper portion of the address.
A 64-bit RISC-V implementation can't even use this approach,
so you end up loading addresses indirectly from a code or data word of memory,
and *that* is what receives the relocation.
So, the loader will need to understand how to perform three or four different kinds of relocations:

* Absolute 32-bit relocation
* Absolute 64-bit relocation
* Upper 20-bits for LUI
* Lower 12-bits for ADDI

This can be encoded easily enough in the relocation segment of the file.
You just need to make the relocation record format known to the loader somehow,
either implicitly through the `ph_branch` magic cookie,
or via additional header fields.

## ELF versus AmigaDOS Hunk Format
## Conclusion

t.b.d.

----
<a name="opposingView">1</a>:
For a quite compelling argument against this point of view,
please read this collection of quotes against
[dynamic linking in general,](http://harmful.cat-v.org/software/dynamic-linking/)
and a uniquely ELF-related concept of
[*versioned symbols*.](http://harmful.cat-v.org/software/dynamic-linking/versioned-symbols)

