---
layout: post
title:  "On ELF, Part 2"
date:   2018-01-30 21:00:00
---

## Abstract

The Executable and Linkable Format, ELF, is too complex.
I firmly feel it was created without critically thinking about the ramifications it would have on future tool chains.
In this article, I show how ELF-like features can be safely retrofitted onto contemporary executable formats.
Hopefully, future executable format authors will reconsider their needs more critically in the future before committing to something as complicated as ELF.

## Basic Principles

Before writing this installment,
I had a realization.
One of the big mistakes from Unix,
besides the X Window System,
was the `ld` linker.
At the time, it must have seemed like a great idea!
Put yourself in the original authors' shoes:
why should the kernel spend so much effort relocating a binary
when that image will just appear at the same place in every process?
So, why not just relocate any linked executable at that point *before* the kernel ever gets a chance to see it?
The kernel can be made much simpler
(just read in an opaque binary blob, then call a specified address),
and as a nice side-effect,
it's faster to run loaded programs as well.

But, as we've seen in the previous article,
this can open a can of worms from the security point of view
as well as constrain new features,
such as the new hotness at about this time, component-oriented programming
(what eventually led to CORBA and DCOM).
It turns out that program relocation at load-time is a *good* thing.<sup>[1](#opposingView)</sup>
The design of ELF, in part,
reflects the realization that mistakes were made in the past,
and AT&T wanted to both move forward with new features while preserving at least some of their initial investment.
(Aside: I, personally, have mixed feelings about this;
but, this article is not about those specific feelings.)

So, *why* is `ld` such a big mistake?
Bluntly, it's a tool which, like ELF, fails to adhere to the Unix philosophy of
doing one thing well.
See, `ld` is responsible for at least two services:

* Linking multiple compiler artifacts into a single artifact for later re-use in the construction of software, and,
* Producing a loadable binary from one or more of these re-usable artifacts.

While these two concepts are clearly *related*,
they are most definitely not *the same thing*.
We see that the
[Plan 9 compiler toolchain](http://doc.cat-v.org/bell_labs/new_c_compilers/new_c_compiler.pdf)
partially remedies this past oversight
by keeping software in a binary representation of an assembly language listing
for as long as possible before the very last step of producing the final binary executable.

Basically, there are two principles involved.

**Principle of Linking.**
A linker's job is to coalesce, merge, and perhaps even sort *sections* of equivalent *type*.
If it helps you, think of it as a merge-sort for related code.
A typical program might have hundreds of sections,
which a linker might reduce to a smaller, perhaps still quite numerous, quantity.
Ultimately, by the time you yield a final executable,
it's been massaged down to a much smaller set
(typically, text, data, and BSS).

**Principle of Loading.**
A loader's job is to unmarshall the concrete program representation in memory from an off-line representation.
This *prepares* a program for execution.
In the case of dynamic linking,
a loader *may* perform some basic relocations,
but *it never merges sections of comparable types.*
It just lays them out in the address space somehow.
This can be seen on any Linux installation by looking at a process' memory map layout
(`sudo cat /proc/$PID/maps`,
which will show each dynamically loaded module's text, data, BSS, and stack segments).
I'm sure BSD and Plan 9 have similarly accessible methods of showing this information.

Where `ld` goes wrong, then,
is that it attempts to both *link* and *load* in one step.
The limitations of this approach do not become visible as long as

* Your runtime environment is isolated via a page-capable MMU, and,
* You have no need whatsoever for dynamic linking.

Violate any of these assumptions, and
`ld`'s approach breaks down hard.
This is why `ld` requires so many horrible-looking arguments when linking code together:
one set of options intends to put a choke-hold on `ld` from building an executable or shared object
when all you want is a relocatable module,
while another set is often to do just the opposite.

I mention this only because
I want this article to focus exclusively on *program loading.*
That is, nothing I write in this article is intended to relate to *linking* at all.
The formats below may or may not make suitable targets for linkers.
In fact, there's a great chance that they won't at all.
Plan 9 accepts this.  There's no reason why the progeny of Unix can't either.

So, with the full understanding that we're talking *exclusively* about *loading* programs,
let us now tear ELF a new hole in its address space by illustrating viable alternatives to it.

## ELF versus GEMDOS PRG Format

In the previous article,
I had stated that the `a.out` format was
one of the earliest and most portable of executable formats around.
To illustrate this point,
let's compare [Unix's original `a.out` format](https://www.bell-labs.com/usr/dmr/www/man51.pdf) to
an OS where you might not have expected it to show up:
[Atari TOS and GEMDOS](http://cd.textfiles.com/ataricompendium/BOOK/HTML/CHAP2.HTM#processes),
the two components that make up the Atari ST/TT's operating system.

<table width=100%>
<tr>
<th>Unix</th>
<th>Atari TOS</th>
</tr>
<tr>
<td><pre>struct aout\_unix {
    short   a_magic;    // 0x0085
    short   a_textsz;   // Size of .text segment
    short   a_symsz;    // Size of symbol tables
    short   a_relocsz;  // Size of fixups
    short   a_datasz;   // Size of .data segment
    short   a_padding;
};</pre></td>
<td><pre>struct aout\_tos {
    short   PRG_magic;  // 0x601A
    long    PRG_tsize;  // Size of .text segment
    long    PRG_dsize;  // Size of .data segment
    long    PRG_bsize;  // Size of .bss segment
    long    PRG_ssize;  // Size of symbol tables
    long    PRG_res1;   // reserved
    long    PRGFLAGS;   // Loader flags to TOS
    long    ABSFLAG;    // More flags
    // ... text, data, and othe segments follow
    long    PRG_fixup;  // Offset to fixups
    // ... other content
    // ... fixups
};</pre></td>
</tr>
</table>

Points of note:

* The respective fields appear in different places depending on which header is used.  But, that's OK; ELF 32-bit and 64-bit structures also have fields which move about to support different processor alignment restrictions.
* TOS supports an explicit `.bss` segment, while the original Unix loader did not.  I'm guessing BSS was just a pre-zeroed bunch of bytes tacked onto the end of `.data`, and accounted for in `a_datasz`.
* Interestingly, both the PDP-11 and the 68000 formats supported fixups to resolve code and data references.  This suggests there was a time when Unix did not run with a page-based MMU.

That's it.  The `a.out` format is surprisingly versatile considering its simplicity.
Exact layout doesn't matter,
what matters are the concepts supported.
It gives the loader just enough information to allocate a chunk of memory for code,
a chunk of memory for data and BSS,
to locate the relevant data in the files and load them into the allocated memory,
and then apply fixups to resolve broken references.
The `a.out` binaries were self-contained and self-consistent otherwise:
it was not possible to legally create an `a.out` file
which referred to an undefined symbol.

In the previous article,
I'd stated that `a.out` was intended to be loaded/mapped blindly as an opaque blob.
This is especially evident in the original Unix header,
as the "magic" field, used to identify executables from other file types,
is *literally* a PDP-11 machine language instruction that *jumps over the header.*


## ELF versus AmigaDOS Hunk Format
## Conclusion

t.b.d.

----
<a name="opposingView">1</a>:
For a quite compelling argument against this point of view,
please read this collection of quotes against
[dynamic linking in general,](http://harmful.cat-v.org/software/dynamic-linking/)
and a uniquely ELF-related concept of
[*versioned symbols*.](http://harmful.cat-v.org/software/dynamic-linking/versioned-symbols)

