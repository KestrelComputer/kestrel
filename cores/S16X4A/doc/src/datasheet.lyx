#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
S16X4A Data Sheet (Preliminary)
\end_layout

\begin_layout Author
Samuel A.
 Falvo II
\end_layout

\begin_layout Date
2013-Nov-9
\end_layout

\begin_layout Itemize
64KiB Addressing Space
\end_layout

\begin_layout Itemize
SS0 Load/Store Stack Architecture
\end_layout

\begin_layout Itemize
8-Bit and 16-Bit Memory Accessors
\end_layout

\begin_layout Itemize
16-Bit Internal Architecture
\end_layout

\begin_layout Itemize
All Instructions Execute in 1 Clock Cycle
\end_layout

\begin_layout Itemize
Wishbone Bus Compatible
\end_layout

\begin_layout Itemize
Enhanced Support for External Interrupt Logic
\end_layout

\begin_layout Itemize
Easy to Program
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
The Steamer16 architecture, first defined by Myron Plichota in December
 1999 (see Appendix A), specifies an exceptionally small, relatively high
 performance microprocessor with good qualities for deep-embedded applications
 and easy synthesis on small programmable logic devices.
 Originally consisting of 9 instructions and four opcodes per instruction
 word, the design was later revised to include only 8 instructions, allowing
 for five opcodes per 16-bit word.
 The S16X4 microprocessor is a specific variant of the original Steamer16
 concept.
 The S16X4A enhances the S16X4 further with additional features.
 The processor design caters to ease of programming and easy integration
 with other components in an FPGA development platform.
\end_layout

\begin_layout Subsection
Addressing
\end_layout

\begin_layout Standard
The S16X4A, without the use of external hardware, supports a flat, unified
 address space.
 Unlike most processors that provide at least two addressing modes, the
 S16X4A only offers one addressing mode: stack indirect.
 All memory accessors take their effective address from the top of the parameter
 stack.
\end_layout

\begin_layout Subsection
Data Types
\end_layout

\begin_layout Standard
The S16X4A supports two data types: bytes and words.
 The most basic addressing unit on the S16X4 is an octet (8-bit) byte.
 All addresses consist of 16 bits, thus limiting the S16X4A to 65536 bytes
 of directly addressible space.
\end_layout

\begin_layout Standard
Words consist of two bytes, back to back, placed on an even address boundary.
 The least-significant byte appears at the lower address; thus making the
 S16X4A a little-endian machine.
 When addressing 16-bit words, the S16X4A currently ignores bit 0 of an
 address.
 Hence, the two pointers $AAAA and $AAAB both refer to the same word of
 memory, even though they refer to two different bytes within the same word.
 For compatibility with later generations of processors, all pointers to
 16-bit entities should have bit 0 clear.
 
\end_layout

\begin_layout Section
Internal Architecture
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Block-Diagram-of-Processor"

\end_inset

 illustrates the block diagram of the S16X4 processor.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename block-diagram.pdf
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Block Diagram of the S16X4 Processor.
\begin_inset CommandInset label
LatexCommand label
name "fig:Block-Diagram-of-Processor"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Parameter Stack
\end_layout

\begin_layout Standard
The parameter stack provides the working storage and the means for expression
 evaluation.
 The S16X4A can hold up to six words of data at any given time, arranged
 as a stack.
 The six words are labelled U, V, W, X, Y, and Z, with Z representing the
 top of the stack.
 Presently, only one instruction, LI, can push data onto the stack.
 All other instructions either replace Z directly or consume data from the
 stack on an as-needed basis.
 When popping values off the stack, the processor retains the current value
 for U.
 Contrast with the S16X4, which only provided three registers, and thus
 retained the value for X.
 In the example below, values filled in from popping the stack appear in
 
\emph on
italics
\emph default
, while new or computed values appear in 
\series bold
bold
\series default
.
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="7">
<features tabularvalignment="top">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Instruction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
U
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
V
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
W
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Y
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Z
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LI $1111
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
$1111
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LI $2222
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$1111
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
$2222
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LI $5555
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$1111
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$2222
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
$5555
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ADD
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
5
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
$1111
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
$7777
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SWM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
3
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
3
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
5
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
While having only six stack elements might seem constraining to someone
 familiar with either Forth or Java, it turns out you can do anything that
 (at least) an accumulator- or register/memory-architecture CPU can do with
 as little as three elements.
 For example, suppose you're writing a program that needs to store a value
 at a location 
\begin_inset Formula $Y$
\end_inset

 bytes beyond the start of a buffer whose pointer can be found in an array
 of pointers starting at address 
\begin_inset Formula $\$44+S$
\end_inset

.
 This is a genuinely complex addressing mode by anyone's measure.
 Here's an example S16X4 program that computes this complex effective address:
\begin_inset Foot
status open

\begin_layout Plain Layout
The corresponding W65C816 microprocessor instruction for this operation
 is STA ($44,S),Y.
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code
LI  a         ; Fetch the datum to store.
\end_layout

\begin_layout LyX-Code
FWM
\end_layout

\begin_layout LyX-Code
LI  s         ; Reference our array of pointers.
\end_layout

\begin_layout LyX-Code
FWM
\end_layout

\begin_layout LyX-Code
LI  $44       ; We want element $22 in the array.
\end_layout

\begin_layout LyX-Code
ADD
\end_layout

\begin_layout LyX-Code
FWM
\end_layout

\begin_layout LyX-Code
LI  y         ; Calculate final storage address.
\end_layout

\begin_layout LyX-Code
FWM
\end_layout

\begin_layout LyX-Code
ADD
\end_layout

\begin_layout LyX-Code
SWM           ; Store the datum.
\end_layout

\begin_layout Standard
Observe that no more than two stack cells (Y and Z, specifically) are involved
 in computing the effective address for the subsequent store instruction,
 allowing X to hold onto the value we wish to store during effective address
 calculation.
\end_layout

\begin_layout Standard
Applications should never depend on U, V, or W retaining their values from
 one instruction fetch to another.
 They exist only to facilitate context preservation while handling hardware
 interrupts.
 Correspondingly, interrupt handlers must never use more than three stack
 items at any time whatsoever, for doing so will destroy the interrupted
 program state.
\end_layout

\begin_layout Subsection
ALU
\end_layout

\begin_layout Standard
The arithmetic/logic unit, or ALU, computes identities, sums, bitwise ANDs,
 and bitwise exclusive-ORs of Y and Z.
 The NOP, ADD, AND, and XOR instructions respectively selects which of these
 results will be chosen as the result.
 
\end_layout

\begin_layout Subsection
Instruction Register
\end_layout

\begin_layout Standard
The instruction register (IR) holds the most recently fetched package of
 instructions.
 Since S16X4A opcodes consume only 4 bits in memory, the S16X4A packs four
 instructions per instruction word, as illustrated below.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Slot 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Slot 2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Slot 3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Slot 4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15..12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11..8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7..4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3..0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The processor will execute instructions starting first with slot 1, and
 continuing up to and including slot 4 before fetching another instruction.
 The S16X4A fetches a new instruction word if it detects that all remaining
 opcodes are NOP instructions.
 This includes the case where all four slots contain NOPs.
\end_layout

\begin_layout Standard
If slot 1 contains the LCALL instruction, slots 2, 3, and 4 holds the program
 counter displacement, as shown below.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Slot 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Slot 2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Slot 3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Slot 4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$C
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Word displacement
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Program Counter Register
\end_layout

\begin_layout Standard
The P register holds the location of the next program literal or instruction
 word.
 It contains only 15 bits, hard-wiring bit 0 to zero to enforce even addressing
 while fetching instructions.
 
\end_layout

\begin_layout Subsection
T-Counter
\end_layout

\begin_layout Standard
This internal register controls when the processor should fetch an instruction
 word, when it is safe to perform non-program memory references, et.
 al.
 In essence, it determines which slot in the instruction register is currently
 being executed, and defines extra 
\begin_inset Quotes eld
\end_inset

slots
\begin_inset Quotes erd
\end_inset

 for handling reset logic, instruction fetching, etc.
\end_layout

\begin_layout Subsection
Control and Random Logic
\end_layout

\begin_layout Standard
The random logic portion of the processor interprets the currently executing
 instruction, if any, the T-counter, as well as the current state of any
 bus transaction in progress to decide how best to proceed.
 It can either fetch another instruction word, advance to the next, delay
 the current bus transaction until some external device says it's OK to
 proceed, etc.
\end_layout

\begin_layout Section
Hardware Interface
\end_layout

\begin_layout Subsection
Logic Symbol
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename logic-symbol.pdf
	BoundingBox 0bp 600bp 306bp 792bp
	clip

\end_inset


\end_layout

\begin_layout Subsection
Signal Descriptions
\end_layout

\begin_layout Standard
The S16X4 complies with Wishbone B3 bus master standards with a 16-bit port
 size and 8-bit granularity.
\end_layout

\begin_layout Subsubsection
SYSCON Signals
\end_layout

\begin_layout Description
CLK_I.
 Provides the standard time-base for the processor.
 All processor state transitions occur on the rising edge of this signal.
\end_layout

\begin_layout Description
RES_I.
 When asserted during the rising edge of CLK_I, the processor resets to
 its power-on default state, immediately commencing a new instruction packet
 fetch.
 See section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Initialization"

\end_inset

 for more details.
\end_layout

\begin_layout Subsubsection
MASTER Signals
\end_layout

\begin_layout Description
ABORT_I.
 If asserted during an instruction execution cycle, this causes the S16X4A
 to prevent any parameter stack register updates, and forces the next cycle
 to fetch a new instruction packet.
 External memory management hardware typically relies this signal to force
 the processor to execute a trap handler in a way that preserves restartability
 of the offending instruction.
 The S16X4A ignores this signal while fetching instruction packets; therefore,
 this signal cannot prevent updates to the program counter.
\end_layout

\begin_layout Description
ACK_I.
 If negated upon the rising edge of CLK_I during a read or write bus transaction
, the processor will insert a wait-state, holding the entire processor state
 as-is.
 If asserted during a CLK_I rising edge, the bus transaction completes,
 thus allowing the processor to make progress.
 However, if the processor does not require the use of the bus, namely when
 either CYC_O or STB_O are negated, the state of ACK_I will be ignored,
 allowing the processor to make progress at the CLK_I frequency regardless
 of external bus activity.
\end_layout

\begin_layout Description
ADR_O(15:1).
 This 15-bit bus provides the word address for an external memory or peripheral
 to decode.
 This bus is valid only while STB_O remains asserted; if STB_O is negated,
 the value on this bus is undefined.
\end_layout

\begin_layout Description
CYC_O.
 This signal serves as a flag to external bus arbitration logic that the
 S16X4 wishes to use the bus, asserting it when it has data to transfer,
 and negating it otherwise.
 As such, CYC_O qualifies 
\emph on
all
\emph default
 other bus signals except for RES_I and CLK_I.
\end_layout

\begin_layout Description
DAT_I(15:0).
 When reading from external memory or peripherals, the addressed memory
 or peripheral puts its data on this bus.
 This bus must be valid at least by the time ACK_I is asserted.
 The processor senses the state of this bus only when it asserts STB_O and
 negates WE_O; it ignores it otherwise.
\end_layout

\begin_layout Description
DAT_O(15:0).
 When writing to external memory or peripherals, the addressed memory or
 peripheral must accept data from this bus.
 This bus will remain valid at least until ACK_I is asserted and the following
 CLK_I rising edge.
 The processor will place valid data on this bus only while asserting STB_O.
 Peripherals must never trust the value on this bus when the processor negates
 STB_O.
\end_layout

\begin_layout Description
SEL_O(1:0).
 These signals indicates which byte-lanes are valid.
 SEL_O(1) indicates that the processor expects valid data on DAT_I(15:8)
 or that the it drives valid data on DAT_O(15:8), while SEL_O(0) does the
 same respectively for DAT_I(7:0) and DAT_O(7:0).
 STB_O qualifies these signals.
 Assertion of both signals implies a full 16-bit transfer.
\end_layout

\begin_layout Description
STB_O.
 This signal qualifies a single bus transfer.
 As of this writing, the S16X4 supports neither read-modify-write bus transactio
ns nor burst transactions; thus, the S16X4 maps individual transfers to
 their own transactions by driving STB_O and CYC_O with the same state for
 any given clock cycle.
 It's important to remember, however, that CYC_O requests the use of the
 bus, while STB_O qualifies a single bus transfer.
 Future generations of this processor may exploit this semantic of the Wishbone
 bus without notice.
 Thus, device-enable and acknowledgement signals should be derived from
 STB_O 
\begin_inset Formula $\wedge$
\end_inset

 CYC_O, not just CYC_O, and certainly never from STB_O alone.
 
\end_layout

\begin_layout Description
WE_O.
 If asserted, the current bus transaction is a write cycle (data on DAT_O(15:0)).
 If negated, the processor will expect an external peripheral or memory
 to drive data on its DAT_I(15:0) bus.
 STB_O qualifies this signal.
\end_layout

\begin_layout Description
VPA_O.
 Also known as TGA_O(1).
 When asserted, the address on the bus refers to a valid program address.
 This signal will be asserted while the processor is fetching either an
 instruction packet or instruction operands.
 STB_O qualifies this signal.
\end_layout

\begin_layout Description
VDA_O.
 Also known as TGA_O(0).
 When asserted, the address on the bus refers to some kind of data.
 If VPA_O is negated, the address corresponds to data memory or peripherals;
 otherwise, the fetch is for an instruction operand.
 If negated, the fetch must be for an instruction packet.
 STB_O qualifies this signal.
 To summarize:
\end_layout

\begin_layout Description
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
VPA_O
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
VDA_O
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Type of Memory Access
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Not possible except when (CYC_O
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\wedge$
\end_inset

STB_O)
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 = 0 as well.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Data memory access (fetch or store).
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Instruction packet fetch.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Instruction operand fetch.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Timing Diagrams
\end_layout

\begin_layout Subsubsection
Reset Timing
\end_layout

\begin_layout Standard
Reset timing follows standard Wishbone B3 recommendations.
 For any rising clock edge, the S16X4A will reset immediately if RES_I becomes
 asserted, and will continue to reset for as long as RES_I remains asserted,
 plus one cycle thereafter.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename timing-reset.pdf
	BoundingBox 107bp 500bp 535bp 746bp
	clip

\end_inset


\end_layout

\begin_layout Subsubsection
Memory Read
\end_layout

\begin_layout Standard
Read timing follows standard Wishbone B3 recommendations.
 For logic that responds fast enough, single-cycle transactions (as seen
 in clock cycle 2) are supported; just make sure the data is valid on the
 DAT_I inputs no later than the minimum set-up time to the next rising clock
 edge.
\begin_inset Foot
status open

\begin_layout Plain Layout
Consult the timing reports generated by your Verilog synthesis for these
 data.
 Since this document describes the behavior of a Verilog model, no concrete
 timing information can be provided.
\end_layout

\end_inset

 For slower devices, or for those devices which require additional clocking
 requirements (e.g., synchronous memories), the ACK_I signal may be negated
 as long as necessary to insert wait states, as per cycles 3, 4, and 5.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename timing-read.pdf
	BoundingBox 107bp 500bp 535bp 746bp
	clip

\end_inset


\end_layout

\begin_layout Subsubsection
Memory Write
\end_layout

\begin_layout Standard
Write timing follows standard Wishbone B3 recommendations.
 For logic that responds fast enough, single-cycle transactions (as seen
 in clock cycle 2) are supported.
 For slower devices, or for those devices which require additional clocking
 requirements (e.g., synchronous memories), the ACK_I signal may be negated
 as long as necessary to insert wait states, as per cycles 3, 4, and 5.
 Observe that VPA_O will never assert during a write cycle.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename timing-write.pdf
	BoundingBox 107bp 500bp 535bp 746bp
	clip

\end_inset


\end_layout

\begin_layout Subsubsection
Instruction Fetch Timing
\end_layout

\begin_layout Standard
Instruction fetches occur by issuing memory read cycles to program space
 (VPA=1, VDA=0; see cycles 2, 6, and 7).
 Depending on the instructions fetched, between zero and four execution
 cycles occur, whereby the state of the processor bus indicates program
 operand fetches (VPA=1, VDA=1; see cycles 3, 4, and 8), data memory reads
 (see cycles 9 and 11) and writes (see cycle 5).
 The following timing diagram shows a sample trace with no wait states,
 involving three instruction word fetches and their subsequent instruction
 execution cycles and effects.
 Observe how instructions which operate exclusively on the parameter stack
 don't require external memory access, and so release the bus completely
 (see cycle 10).
 Also observe how an instruction word consisting entirely of NOP instructions
 results in an immediate fetch of the subsequent instruction word (see cycles
 6 and 7).
\end_layout

\begin_layout Standard
Calculating the number of cycles an instruction word takes follows a fairly
 simple formula.
 If we let 
\begin_inset Formula $n$
\end_inset

 equal the number of instructions in an instruction word, then that word
 will take 
\begin_inset Formula $n+1$
\end_inset

 cycles to execute (remembering to include the fetch cycle as well).
 Note that 
\emph on
trailing
\emph default
 NOP instructions do not count as instructions, since the S16X4A will fetch
 the next instruction word when it sees all subsequent instructions do nothing
 productive.
 Leading NOPs, however, 
\emph on
do
\emph default
 count.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename timing-instruction-fetch.pdf
	BoundingBox 107bp 500bp 535bp 746bp
	clip

\end_inset


\end_layout

\begin_layout Subsubsection
Interrupt Dispatch Timing
\end_layout

\begin_layout Standard
The S16X4A lacks a built-in state-machine for dispatching interrupts.
 However, it does provide support for external interrupt logic.
 The interrupt controller checks for CYC=1, STB=1, VPA=1, VDA=0, and interrupt
 pending.
 If these conditions agree, the interrupt controller inhibits access to
 the addressed hardware, preserves the address put on the bus by the S16X4A
 in a register, and takes control over the bus for two consecutive cycles.
 During the first cycle, $1E00 appears on the data bus, corresponding to
 a LI instruction followed by GO.
 The second cycle contains the address of the desired interrupt handler.
 When the interrupt handler desires to return from the interrupt, it executes
 a sequence of instructions like the following:
\end_layout

\begin_layout LyX-Code
LI  irqReturnAddress
\end_layout

\begin_layout LyX-Code
FWM
\end_layout

\begin_layout LyX-Code
GO
\end_layout

\begin_layout Standard
where irqReturnAddress addresses a 16-bit wide register in the interrupt
 controller's register set.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Initialization"

\end_inset

Initialization
\end_layout

\begin_layout Standard
After reset, the S16X4 fetches its first instruction at address $0000.
 The state of the parameter stack remains undefined until explicitly initialized
 in software.
\end_layout

\begin_layout Section
Instruction Set
\end_layout

\begin_layout Standard
Unless stated otherwise, the S16X4A will always consume an appropriate number
 of elements from the parameter stack prior to generating its results.
\end_layout

\begin_layout Subsection
NOP (0)
\end_layout

\begin_layout Subsubsection*
Function
\end_layout

\begin_layout LyX-Code
U := U
\end_layout

\begin_layout LyX-Code
V := V
\end_layout

\begin_layout LyX-Code
W := W
\end_layout

\begin_layout LyX-Code
X := X
\end_layout

\begin_layout LyX-Code
Y := Y
\end_layout

\begin_layout LyX-Code
Z := Z
\end_layout

\begin_layout LyX-Code
P := P
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
Takes no action for one execution cycle.
\end_layout

\begin_layout Subsection
LIT (1)
\end_layout

\begin_layout Subsubsection*
Function
\end_layout

\begin_layout LyX-Code
U := V
\end_layout

\begin_layout LyX-Code
V := W
\end_layout

\begin_layout LyX-Code
W := X
\end_layout

\begin_layout LyX-Code
X := Y
\end_layout

\begin_layout LyX-Code
Y := Z
\end_layout

\begin_layout LyX-Code
Z := WordAt(P)
\end_layout

\begin_layout LyX-Code
P := P
\begin_inset Formula $+$
\end_inset

2
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
Fetches the word pointed at by the program counter, placing it onto the
 parameter stack.
 The program counter automatically increments to the next word.
\end_layout

\begin_layout Subsection
FWM (2)
\end_layout

\begin_layout Subsubsection*
Function
\end_layout

\begin_layout LyX-Code
U := U
\end_layout

\begin_layout LyX-Code
V := V
\end_layout

\begin_layout LyX-Code
W := W
\end_layout

\begin_layout LyX-Code
X := X
\end_layout

\begin_layout LyX-Code
Y := Y
\end_layout

\begin_layout LyX-Code
Z := WordAt(Z
\begin_inset Formula $\wedge$
\end_inset

$FFFE)
\end_layout

\begin_layout LyX-Code
P := P
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
Fetches a word from memory.
 Z must hold the address to fetch from; note that bit 0 of the pointer is
 ignored.
 After completing the bus transaction, Z will contain the word stored at
 that location.
\end_layout

\begin_layout Subsection
SWM (3)
\end_layout

\begin_layout Subsubsection*
Function
\end_layout

\begin_layout LyX-Code
WordAt(Z
\begin_inset Formula $\wedge$
\end_inset

$FFFE) := Y
\end_layout

\begin_layout LyX-Code
U := U
\end_layout

\begin_layout LyX-Code
V := U
\end_layout

\begin_layout LyX-Code
W := U
\end_layout

\begin_layout LyX-Code
X := V
\end_layout

\begin_layout LyX-Code
Y := W
\end_layout

\begin_layout LyX-Code
Z := X
\end_layout

\begin_layout LyX-Code
P := P
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
Stores the contents of Y into the word addressed by Z.
 Note that bit 0 of Z is ignored.
\end_layout

\begin_layout Subsection
ADD (4)
\end_layout

\begin_layout Subsubsection*
Function
\end_layout

\begin_layout LyX-Code
U := U
\end_layout

\begin_layout LyX-Code
V := U
\end_layout

\begin_layout LyX-Code
W := V
\end_layout

\begin_layout LyX-Code
X := W
\end_layout

\begin_layout LyX-Code
Y := X
\end_layout

\begin_layout LyX-Code
Z := Z
\begin_inset Formula $+$
\end_inset

Y
\end_layout

\begin_layout LyX-Code
P := P
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
Adds two words on the parameter stack, yielding a single result.
\end_layout

\begin_layout Subsection
AND (5)
\end_layout

\begin_layout Subsubsection*
Function
\end_layout

\begin_layout LyX-Code
U := U
\end_layout

\begin_layout LyX-Code
V := U
\end_layout

\begin_layout LyX-Code
W := V
\end_layout

\begin_layout LyX-Code
X := W
\end_layout

\begin_layout LyX-Code
Y := X
\end_layout

\begin_layout LyX-Code
Z := Z
\begin_inset Formula $\wedge$
\end_inset

Y
\end_layout

\begin_layout LyX-Code
P := P
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
Computes the bit-wise AND of Y and Z, yielding a single result.
\end_layout

\begin_layout Subsection
XOR (6)
\end_layout

\begin_layout Subsubsection*
Function
\end_layout

\begin_layout LyX-Code
U := U
\end_layout

\begin_layout LyX-Code
V := U
\end_layout

\begin_layout LyX-Code
W := V
\end_layout

\begin_layout LyX-Code
X := W
\end_layout

\begin_layout LyX-Code
Y := X
\end_layout

\begin_layout LyX-Code
Z := Z
\begin_inset Formula $\oplus$
\end_inset

Y
\end_layout

\begin_layout LyX-Code
P := P
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
Computes the bit-wise exclusive-OR of Y and Z, yielding a single result.
\end_layout

\begin_layout Subsection
ZGO (7)
\end_layout

\begin_layout Subsubsection*
Function
\end_layout

\begin_layout LyX-Code
U := U
\end_layout

\begin_layout LyX-Code
V := U
\end_layout

\begin_layout LyX-Code
W := U
\end_layout

\begin_layout LyX-Code
X := V
\end_layout

\begin_layout LyX-Code
Y := W
\end_layout

\begin_layout LyX-Code
Z := X
\end_layout

\begin_layout LyX-Code
P := (Y
\begin_inset Formula $\not=$
\end_inset

0)
\begin_inset Formula $\rightarrow$
\end_inset

P ; Z
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
If Y holds a non-zero value, continue processing with the next instruction
 in the current instruction word.
 Otherwise, jump to the address contained in Z.
\end_layout

\begin_layout Subsection
FBM (A)
\end_layout

\begin_layout Subsubsection*
Function
\end_layout

\begin_layout LyX-Code
U := U
\end_layout

\begin_layout LyX-Code
V := V
\end_layout

\begin_layout LyX-Code
W := W
\end_layout

\begin_layout LyX-Code
X := X
\end_layout

\begin_layout LyX-Code
Y := Y
\end_layout

\begin_layout LyX-Code
Z := ZeroExtend(ByteAt(Z))
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
Fetches the byte contained at the address in Z.
 Note all 16-bits of Z comprise the byte address.
\end_layout

\begin_layout Subsection
SBM (B)
\end_layout

\begin_layout Subsubsection*
Function
\end_layout

\begin_layout LyX-Code
ByteAt(Z) := Y
\begin_inset Formula $\wedge$
\end_inset

$00FF
\end_layout

\begin_layout LyX-Code
U := U
\end_layout

\begin_layout LyX-Code
V := U
\end_layout

\begin_layout LyX-Code
W := U
\end_layout

\begin_layout LyX-Code
X := V
\end_layout

\begin_layout LyX-Code
Y := W
\end_layout

\begin_layout LyX-Code
Z := X
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
Stores the byte held in Y(7:0) at the memory location referenced by Z.
 Note all 16-bits of Z comprise the byte address.
\end_layout

\begin_layout Subsection
LCALL (C)
\end_layout

\begin_layout Subsubsection*
Function
\end_layout

\begin_layout LyX-Code
U := V
\end_layout

\begin_layout LyX-Code
V := W
\end_layout

\begin_layout LyX-Code
W := X
\end_layout

\begin_layout LyX-Code
X := Y
\end_layout

\begin_layout LyX-Code
Y := Z
\end_layout

\begin_layout LyX-Code
Z := P
\end_layout

\begin_layout LyX-Code
P := P + 2*SignExtend(IR[11:0])
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
Calls a subroutine.
 The S16X4A assumes the subroutine resides at some signed displacement from
 the current program counter value.
 The displacement value comes from slots 2, 3, and 4 of the current instruction
 packet.
 Z holds the return address upon entry.
\end_layout

\begin_layout Standard
This instruction may only appear in slot 1.
 Instruction behavior becomes unpredictable if used in slots 2, 3, or 4.
\end_layout

\begin_layout Subsection
ICALL (D)
\end_layout

\begin_layout Subsubsection*
Function
\end_layout

\begin_layout LyX-Code
U := U
\end_layout

\begin_layout LyX-Code
V := V
\end_layout

\begin_layout LyX-Code
W := W
\end_layout

\begin_layout LyX-Code
X := X
\end_layout

\begin_layout LyX-Code
Y := Y
\end_layout

\begin_layout LyX-Code
Z := P
\end_layout

\begin_layout LyX-Code
P := Z
\begin_inset Formula $\wedge$
\end_inset

$FFFE
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
Calls a subroutine.
 The S16X4A assumes the subroutine address already sits in the Z register.
 Z will hold the return address upon entry.
\end_layout

\begin_layout Subsection
GO (E)
\end_layout

\begin_layout Subsubsection*
Function
\end_layout

\begin_layout LyX-Code
U := U
\end_layout

\begin_layout LyX-Code
V := U
\end_layout

\begin_layout LyX-Code
W := V
\end_layout

\begin_layout LyX-Code
X := W
\end_layout

\begin_layout LyX-Code
Y := X
\end_layout

\begin_layout LyX-Code
Z := Y
\end_layout

\begin_layout LyX-Code
P := Z
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
Unconditionally jumps to the address in Z.
 The processor discards the current instruction register contents, causing
 an immediate fetch for a new instruction word.
\end_layout

\begin_layout Subsection
NZGO (F)
\end_layout

\begin_layout Subsubsection*
Function
\end_layout

\begin_layout LyX-Code
U := U
\end_layout

\begin_layout LyX-Code
V := U
\end_layout

\begin_layout LyX-Code
W := U
\end_layout

\begin_layout LyX-Code
X := V
\end_layout

\begin_layout LyX-Code
Y := W
\end_layout

\begin_layout LyX-Code
Z := X
\end_layout

\begin_layout LyX-Code
P := (Y
\begin_inset Formula $\not\not=$
\end_inset

0)
\begin_inset Formula $\rightarrow$
\end_inset

Z ; P
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
If Y holds a non-zero value, branch to the address in Z.
 Otherwise, continue with the next instruction in the currently fetched
 instruction word, if any.
\end_layout

\begin_layout Section
Roadmap
\end_layout

\begin_layout Subsection
32- or 64-Bit Successors
\end_layout

\begin_layout Standard
Contemporary applications work extensively with graphics data, like it or
 not.
 The freedom and flexibility of a fully bitmapped display, however, is paid
 for in memory consumed by a frame buffer.
 A simple 640
\begin_inset Formula $\times$
\end_inset

480, monochrome bitmapped display consumes 38KiB of memory; more than half
 that addressible by the S16X4A.
 For a true-color display at the same resolution, a framebuffer will consume
 a minimum of 921 600 bytes of storage.
 Additionally, the instruction set for the S16X4A lacks many useful primitives,
 including but not limited to multiplication, bit-shifts, etc.
 To overcome these limitations in a performant manner often involves the
 use of a look-up table of some kind.
\end_layout

\begin_layout Standard
To that end, working with a larger address space motivates the consideration
 for wider data paths inside the processor core itself.
 A hypothetical 32-bit variant of the S16X4A would have several useful character
istics:
\end_layout

\begin_layout Itemize
It can pack 8 4-bit instructions per instruction word fetched.
 This matches nicely the average basic block length of 8 instructions.
\begin_inset Foot
status open

\begin_layout Plain Layout
http://piotrbania.com/all/articles/bb_instr_stats.html , accessed 2012-Aug-23.
\end_layout

\end_inset

 This translates to a small yet measurable performance increase, particularly
 useful inside inner-loops, for the microprocessor will need to issue fewer
 instruction fetches for the same amount of work done.
 It also reduces the size of a program by roughly halving the number of
 instruction words fetched for a given number of operands fetched.
 It decreases the best-case instruction delays from 1.250 cycles to 1.125
 cycles.
\end_layout

\begin_layout Itemize
If we widen the instructions to 5 bits, we can add support for many missing
 features, such as an internal return stack for fast subroutine support,
 bit-shift operators, multiply-step instructions, etc.
 We pay for this by packing fewer instructions per instruction word, however;
 with 5-bit opcodes, we can reliably pack only 6 5-bit opcodes.
 Good code density can still be expected, but not as good as having 8.
\end_layout

\begin_layout Itemize
Support for a flat 4GiB address space, providing more than enough storage
 space for large bitmapped displays or extensive look-up tables.
\end_layout

\begin_layout Standard
A 64-bit variant of the architecture may not offer any useful advantage,
 again excepting for the case of larger address space.
 This poses an interesting design challenge: does one simply widen everything
 to 64-bits including the instruction word, or can one be made which retains
 an essentially 32-bit instruction word (for the purposes of best code density)
 while retaining an essentially 64-bit data word width? If the latter approaches
 are taken, how do we handle 64-bit literals in an otherwise 32-bit instruction
 stream? A 64-bit Steamer adaptation will require further research before
 any predictions on its characteristics can be made.
\end_layout

\begin_layout Subsection
Macro-instruction Execution
\end_layout

\begin_layout Standard
Many instruction patterns emerge as you become more familiar with assembly-level
 programming of the S16X4A processor.
 For example, pushing a literal address then executing a GO instruction,
 takes two cycles to execute, not including instruction word fetches.
 It's conceivable, then, that the processor can recognize this sequence
 of instructions (opcodes 1, E, in that order) and implement an inline jump
 behavior in a single cycle.
 Conditional branches most likely would benefit the most from this optimization,
 as they're most likely to be found inside loop bodies.
\end_layout

\begin_layout Standard
Fetching a word from memory and using it to operate on the parameter stack
 happens quite frequently.
 For example, to add two variables in memory together, and store it in a
 third, you might use this code:
\end_layout

\begin_layout LyX-Code
LIT var1
\end_layout

\begin_layout LyX-Code
FWM
\end_layout

\begin_layout LyX-Code
LIT var2
\end_layout

\begin_layout LyX-Code
FWM
\end_layout

\begin_layout LyX-Code
ADD
\end_layout

\begin_layout LyX-Code
LIT var3
\end_layout

\begin_layout LyX-Code
SWM
\end_layout

\begin_layout Standard
The first and perhaps most obvious optimization involves the processor recognizi
ng a fetch/operate pattern (in this case, opcodes 2, 4 in that order).
 The processor, in this case, would have a modified data path inside the
 ALU circuitry, allowing Z to appear on the address bus, while the DAT_I
 signals route directly to the ALU Z input.
 In this way, fetching a value and adding, ANDing, or XORing can be accomplished
 in a single cycle instead of two.
\end_layout

\begin_layout Standard
You might think it'd be worth optimizing LIT/FWM combinations since they
 happen frequently as well.
 However, doing so continues to require two bus cycles (one to fetch the
 address, and one to fetch what's at that address), so the net result is
 a wash.
\end_layout

\begin_layout Standard
Since it'd generally prove difficult to recognize instruction sequences
 across instruction word boundaries, this optimization would make more sense
 on wider Steamer architectures (32-bit or larger), where greater opportunities
 for larger patterns exist to be recognized.
\end_layout

\begin_layout Section
Original Steamer16 Announcement
\end_layout

\begin_layout Standard
The following e-mail message has been edited only so as to fit the typesetting
 limitations used in this data-sheet.
\end_layout

\begin_layout LyX-Code
To: <MISC> 
\end_layout

\begin_layout LyX-Code
Subject: 16-bit stack machine implemented on a Cypress CY37128 CPLD 
\end_layout

\begin_layout LyX-Code
From: "Myron Plichota" <myron.plichota@xxxxxxxxxxxx> 
\end_layout

\begin_layout LyX-Code
Date: Fri, 31 Dec 1999 11:01:53 -0500
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

I have developed a 16-bit zero-operand stack machine that I call 
\end_layout

\begin_layout LyX-Code
Steamer16.
 It fits on the Cypress CY37128 CPLD in an 84-pin PLCC
\end_layout

\begin_layout LyX-Code
package.
 Using the 125 MHz speed grade, wirewrapped operation at
\end_layout

\begin_layout LyX-Code
20 MHz is predicted by the simulator.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Unfortunately, a dual-stack Forth architecture doesn't fit in the
\end_layout

\begin_layout LyX-Code
128 macrocells available.
 Consequently the design isn't a true Forth
\end_layout

\begin_layout LyX-Code
chip, but it is a zero-operand stack machine nonetheless.
 In the
\end_layout

\begin_layout LyX-Code
future I would like to fit a true Forth architecture to one of the
\end_layout

\begin_layout LyX-Code
CPLD or FPGA architectures that include on-chip RAM blocks for the
\end_layout

\begin_layout LyX-Code
stacks.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Being fearfull of actually fitting the design to the target device,
\end_layout

\begin_layout LyX-Code
the instruction set and architecture was minimized to a ridiculous
\end_layout

\begin_layout LyX-Code
extent, and it indeed just barely fits.
 In the future, more elaborate
\end_layout

\begin_layout LyX-Code
implementations may be implemented on larger devices not suitable for
\end_layout

\begin_layout LyX-Code
hobby projects due to exotic packaging.
 For this reason, the document-
\end_layout

\begin_layout LyX-Code
ation contains nerdy phrases typical of growth-path specifications,
\end_layout

\begin_layout LyX-Code
but don't let that distract you from understanding the Steamer16 init-
\end_layout

\begin_layout LyX-Code
ial implementation that exists today.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

I plan to design a companion chip, also using the CY37128 to provide
\end_layout

\begin_layout LyX-Code
a timer, parallel I/O, a funnel shifter, memory decoder/wait state
\end_layout

\begin_layout LyX-Code
logic, and glue logic for a 16-bit 3-port multiplier/accumulator.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

I think it might be bad netiqette to attach the 40Kbyte zip file I
\end_layout

\begin_layout LyX-Code
have available because of the load on the MISC server.
 It contains
\end_layout

\begin_layout LyX-Code
the assembler, JEDEC file, and side documentation.
 Interested parties
\end_layout

\begin_layout LyX-Code
should e-mail me for a copy.
 Please withold any technical questions
\end_layout

\begin_layout LyX-Code
until having read the documentation package.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

BTW, I am well aware of the shortcomings of the Steamer16 implement-
\end_layout

\begin_layout LyX-Code
ation, so please don't take me to task over it.
 My defense is: 1) it
\end_layout

\begin_layout LyX-Code
fits on a low-cost CPLD in a package hobbyists can deal with 2) com-
\end_layout

\begin_layout LyX-Code
panion chips can alleviate some of the shortcomings 3) at 20 MHz, it
\end_layout

\begin_layout LyX-Code
can clunk through inelegant code sequences quickly  (sic)
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Following is an excerpt from the assembler documentation (STASM.TXT),
\end_layout

\begin_layout LyX-Code
part of the zipped package.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Happy New Millenium, MISCers! Myron Plichota
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

************************************************************
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Programming Model:
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

The Steamer architecture consists of a program counter (P) and a 3-
\end_layout

\begin_layout LyX-Code
deep RPN evaluation stack (TOP, 2ND, 3RD).
 P is cleared on reset.
\end_layout

\begin_layout LyX-Code
The stack registers are undefined until loaded under program control.
\end_layout

\begin_layout LyX-Code
There is no program status word or carry flag.
 P addresses instruction
\end_layout

\begin_layout LyX-Code
groups, not necessarily individual instructions.
 Steamer architecture
\end_layout

\begin_layout LyX-Code
mandates operations on natural size words without forbidding other
\end_layout

\begin_layout LyX-Code
data types.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Steamer16 implements the Steamer architecture in 16 bits, with no
\end_layout

\begin_layout LyX-Code
enhancements.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Stack diagrams:
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Stack diagrams are used to describe instruction behavior by showing
\end_layout

\begin_layout LyX-Code
both the inputs on the stack and the results in a concise notation.
\end_layout

\begin_layout LyX-Code
The input list is on the left-hand side of the "--" before/after
\end_layout

\begin_layout LyX-Code
separator, the results are on the right-hand side.
  eg.
 ( 3RD 2ND
\end_layout

\begin_layout LyX-Code
TOP -- 3RD 2ND TOP)
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

The input list shows the proper order of input entry in left-to-
\end_layout

\begin_layout LyX-Code
right order.
 The input list shows only the requisite stack entries.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

The output list shows all three entries.
 The symbols x, y, and z,
\end_layout

\begin_layout LyX-Code
are used to denote the original values of any surviving independent
\end_layout

\begin_layout LyX-Code
stack entries.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Instruction Descriptions: opcodes are in hexadecimal order
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

NOP, {0} ( -- x y z)           no operation
\end_layout

\begin_layout LyX-Code
lit, {8} ( -- y z data)        P++ read memory at P, increment P
\end_layout

\begin_layout LyX-Code
@,   {9} ( addr -- x y data)   read memory at addr
\end_layout

\begin_layout LyX-Code
!,   {A} ( data addr -- x x x) write data to memory at addr
\end_layout

\begin_layout LyX-Code
+,   {B} ( n1 n2 -- x x n1+n2) add 2ND to TOP
\end_layout

\begin_layout LyX-Code
AND, {C} ( n1 n2 -- x x n1&n2) and 2ND to TOP
\end_layout

\begin_layout LyX-Code
OR,  {D} ( n1 n2 -- x x n1|n2) or 2ND to TOP
\end_layout

\begin_layout LyX-Code
XOR, {E} ( n1 n2 -- x x n1^n2) exclusive-or 2ND to TOP
\end_layout

\begin_layout LyX-Code
zgo, {F} ( flg addr -- x x x)  if flg equals 0 then jump to addr 
\end_layout

\begin_layout LyX-Code
                               else continue
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Notes:
\end_layout

\begin_layout LyX-Code
  1) 3RD is sticky.
 When the stack shrinks it holds its value.
\end_layout

\begin_layout LyX-Code
  2) lit, is the only instruction that grows the stack, 
\end_layout

\begin_layout LyX-Code
destroying 3RD.
\end_layout

\begin_layout LyX-Code
  3) The Steamer16 instruction set contains no additions to the 
\end_layout

\begin_layout LyX-Code
Steamer required instruction set.
\end_layout

\begin_layout LyX-Code
  4) Opcodes {1..7} are implemented as no operation and are not 
\end_layout

\begin_layout LyX-Code
part of the Steamer required instruction set.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Instruction Timing:
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Steamer16 executes all instructions in 1 clock cycle.
 A quartet
\end_layout

\begin_layout LyX-Code
fetch cycle is required when the current quartet has finished
\end_layout

\begin_layout LyX-Code
executing or a jump is taken.
 For sequential execution, quartets
\end_layout

\begin_layout LyX-Code
are fetched and executed in 5 clocks.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Software delays are deterministic and may be counted from the
\end_layout

\begin_layout LyX-Code
fetch of any quartet.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

The adder for the +, instruction is implemented as a cascade of
\end_layout

\begin_layout LyX-Code
8 2-bit ripple-carry adder cells.
 Running on a 125 MHz part, the
\end_layout

\begin_layout LyX-Code
maximum clock frequency is 20 MHz for unambiguous results.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Instruction timing is not mandated in the Steamer architecture.
\end_layout

\end_body
\end_document
